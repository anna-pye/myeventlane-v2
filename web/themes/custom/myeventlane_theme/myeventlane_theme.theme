<?php

/**
 * @file
 * Theme hooks for MyEventLane.
 */

/**
 * Implements hook_preprocess_page() for front page.
 *
 * Loads category terms for the hero section.
 */
function myeventlane_theme_preprocess_page(array &$variables): void {
  // Check if this is the front page.
  if (\Drupal::service('path.matcher')->isFrontPage()) {
    // Load category terms.
    $term_storage = \Drupal::entityTypeManager()->getStorage('taxonomy_term');
    $terms = $term_storage->loadByProperties(['vid' => 'categories']);
    
    $categories = [];
    foreach ($terms as $term) {
      $categories[] = [
        'tid' => $term->id(),
        'name' => $term->label(),
        'url' => '/events/category/' . $term->id(),
      ];
    }
    
    $variables['event_categories'] = $categories;
    
    // Add calendar data for mini calendar
    $variables['calendar'] = _myeventlane_theme_get_calendar_data();
  }
}

/**
 * Helper function to generate calendar data.
 */
function _myeventlane_theme_get_calendar_data($year = NULL, $month = NULL): array {
  $year = $year ?: date('Y');
  $month = $month ?: date('n');
  
  $first_day = mktime(0, 0, 0, $month, 1, $year);
  $days_in_month = date('t', $first_day);
  $start_day = date('w', $first_day); // 0 = Sunday
  
  // Get events for this month
  $start_date = date('Y-m-01', $first_day);
  $end_date = date('Y-m-t', $first_day);
  
  $query = \Drupal::entityQuery('node')
    ->condition('type', 'event')
    ->condition('status', 1)
    ->condition('field_event_start', $start_date, '>=')
    ->condition('field_event_start', $end_date . 'T23:59:59', '<=')
    ->accessCheck(TRUE);
  
  $nids = $query->execute();
  $events_by_day = [];
  
  if (!empty($nids)) {
    $nodes = \Drupal::entityTypeManager()->getStorage('node')->loadMultiple($nids);
    foreach ($nodes as $node) {
      $event_date = $node->get('field_event_start')->value;
      $day = (int) date('j', strtotime($event_date));
      if (!isset($events_by_day[$day])) {
        $events_by_day[$day] = [];
      }
      $events_by_day[$day][] = [
        'title' => $node->label(),
        'url' => $node->toUrl()->toString(),
      ];
    }
  }
  
  return [
    'year' => $year,
    'month' => $month,
    'month_name' => date('F', $first_day),
    'days_in_month' => $days_in_month,
    'start_day' => $start_day,
    'today' => (int) date('j'),
    'is_current_month' => ($year == date('Y') && $month == date('n')),
    'events_by_day' => $events_by_day,
  ];
}

/**
 * Implements hook_preprocess_page() for category pages.
 *
 * Adds category info and all categories for the hero section.
 */
function myeventlane_theme_preprocess_page__events__category(array &$variables): void {
  // Get the category term ID from the URL.
  $tid = \Drupal::routeMatch()->getParameter('arg_0');
  
  if ($tid) {
    $term = \Drupal::entityTypeManager()->getStorage('taxonomy_term')->load($tid);
    if ($term) {
      $variables['current_category'] = [
        'tid' => $term->id(),
        'name' => $term->label(),
      ];
    }
  }
  
  // Load all categories for the hero chips.
  $term_storage = \Drupal::entityTypeManager()->getStorage('taxonomy_term');
  $terms = $term_storage->loadByProperties(['vid' => 'categories']);
  
  $categories = [];
  foreach ($terms as $term) {
    $categories[] = [
      'tid' => $term->id(),
      'name' => $term->label(),
      'url' => '/events/category/' . $term->id(),
    ];
  }
  
  $variables['event_categories'] = $categories;
}

/**
 * Implements hook_preprocess_page() for calendar page.
 */
function myeventlane_theme_preprocess_page__calendar(array &$variables): void {
  // Load all published events for the calendar.
  $query = \Drupal::entityQuery('node')
    ->condition('type', 'event')
    ->condition('status', 1)
    ->accessCheck(TRUE);

  $nids = $query->execute();
  $events = [];

  if (!empty($nids)) {
    $nodes = \Drupal::entityTypeManager()->getStorage('node')->loadMultiple($nids);
    
    // Category colors.
    $category_colors = [
      'music' => '#7c5cff',
      'sports' => '#ff6f61',
      'food' => '#ffd46f',
      'arts' => '#4ecdc4',
      'business' => '#1a1a2e',
      'community' => '#ff6f61',
      'education' => '#4ecdc4',
      'charity' => '#ff6f61',
    ];

    foreach ($nodes as $node) {
      $start = $node->get('field_event_start')->value;
      $end = $node->hasField('field_event_end') ? $node->get('field_event_end')->value : NULL;
      
      // Get category color.
      $color = '#7c5cff';
      if ($node->hasField('field_category') && !$node->get('field_category')->isEmpty()) {
        $category = $node->get('field_category')->entity;
        if ($category) {
          $cat_name = strtolower($category->label());
          $color = $category_colors[$cat_name] ?? '#7c5cff';
        }
      }

      if ($start) {
        $events[] = [
          'title' => $node->label(),
          'start' => $start,
          'end' => $end,
          'url' => $node->toUrl()->toString(),
          'color' => $color,
        ];
      }
    }
  }

  $variables['calendar_events'] = $events;
}

/**
 * Implements hook_library_info_alter().
 *
 * Dynamically rewrites the 'global-styling' library to point to the current
 * Vite-built CSS file defined in the manifest. This allows hashed filenames
 * generated by Vite (e.g. main.BMgQme3h.css) to be used automatically.
 */
function myeventlane_theme_library_info_alter(array &$libraries, string $extension): void {
  // Only alter this theme's own libraries.
  if ($extension !== 'myeventlane_theme') {
    return;
  }

  // Ensure our library exists before altering it.
  if (!isset($libraries['global-styling'])) {
    return;
  }

  $css_path = _myeventlane_theme_manifest_css();
  if (!$css_path) {
    // Gracefully fallback to whatever the .libraries.yml defines.
    return;
  }

  // Replace the existing CSS with only the hashed Vite output.
  $libraries['global-styling']['css']['theme'] = [
    $css_path => [],
  ];
}

/**
 * Reads the Vite manifest and returns the primary CSS file.
 *
 * @return string|null
 *   Relative path to the CSS file (e.g. 'dist/assets/main.ABC123.css'),
 *   or NULL if the manifest or asset cannot be read.
 */
function _myeventlane_theme_manifest_css(): ?string {
  static $cached = NULL;

  // Return cached value if already processed.
  if ($cached !== NULL) {
    return $cached;
  }

  // Load the theme path.
  $theme_handler = \Drupal::service('extension.list.theme');
  $relative_theme_path = $theme_handler->getPath('myeventlane_theme');

  // Vite manifest path.
  $manifest_path = DRUPAL_ROOT . '/' . $relative_theme_path . '/dist/.vite/manifest.json';
  if (!file_exists($manifest_path)) {
    return $cached = NULL;
  }

  $json = file_get_contents($manifest_path);
  if (!$json) {
    return $cached = NULL;
  }

  $manifest = json_decode($json, TRUE);
  if (!is_array($manifest)) {
    return $cached = NULL;
  }

  // Vite default entry: js/main.js â†’ CSS array.
  if (empty($manifest['js/main.js']['css'][0])) {
    return $cached = NULL;
  }

  // Build theme-relative path.
  $css = $manifest['js/main.js']['css'][0];
  $css = ltrim($css, '/');

  return $cached = "dist/{$css}";
}
<?php

/**
 * @file
 * Theme hooks for MyEventLane.
 */

use Drupal\Core\Cache\CacheableMetadata;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Url;
use Drupal\block_content\Entity\BlockContent;
use Drupal\commerce_order\Entity\OrderInterface;
use Drupal\node\NodeInterface;
use Drupal\taxonomy\TermInterface;
use Drupal\views\ResultRow;
use Drupal\views\ViewExecutable;
use Drupal\views\Views;

/**
 * Implements hook_theme().
 *
 * Registers custom theme components.
 */
function myeventlane_theme_theme(): array {
  return [
    'event_type_pill' => [
      'variables' => [
        'type' => 'none',
        'label' => NULL,
        'size' => 'sm',
        'icon' => NULL,
        'class' => NULL,
      ],
      'template' => 'components/event-type-pill',
    ],
  ];
}

/**
 * Implements hook_preprocess_page().
 *
 * Adds cart block and main menu to header if not already placed.
 */
function myeventlane_theme_preprocess_page(array &$variables): void {
  // Add cart block to header if not already present.
  if (empty($variables['page']['header']['cart_block'])) {
    try {
      $block_manager = \Drupal::service('plugin.manager.block');
      $cart_block = $block_manager->createInstance('commerce_cart', []);
      if ($cart_block && $cart_block->access(\Drupal::currentUser())) {
        $build = $cart_block->build();
        if (!empty($build)) {
          $variables['page']['header']['cart_block'] = $build;
        }
      }
    }
    catch (\Exception $e) {
      // Cart block not available, continue without it.
    }
  }

  // Add main menu to header if not already present.
  if (empty($variables['page']['header']['main_menu'])) {
    try {
      $block_manager = \Drupal::service('plugin.manager.block');
      $menu_block = $block_manager->createInstance('system_menu_block:main', []);
      if ($menu_block && $menu_block->access(\Drupal::currentUser())) {
        $build = $menu_block->build();
        if (!empty($build)) {
          $variables['page']['header']['main_menu'] = $build;
        }
      }
    }
    catch (\Exception $e) {
      // Menu block not available, continue without it.
    }
  }

  // Check if current user is a vendor (for profile link routing).
  $current_user = \Drupal::currentUser();
  if ($current_user->isAuthenticated()) {
    $uid = (int) $current_user->id();
    $is_vendor = FALSE;

    if (\Drupal::moduleHandler()->moduleExists('myeventlane_vendor')) {
      $vendor_storage = \Drupal::entityTypeManager()->getStorage('myeventlane_vendor');

      // Check if user owns a vendor (uid field).
      $owner_ids = $vendor_storage->getQuery()
        ->accessCheck(TRUE)
        ->condition('uid', $uid)
        ->range(0, 1)
        ->execute();

      if (empty($owner_ids)) {
        // Check if user is in field_vendor_users.
        $user_ids = $vendor_storage->getQuery()
          ->accessCheck(TRUE)
          ->condition('field_vendor_users', $uid)
          ->range(0, 1)
          ->execute();

        if (!empty($user_ids)) {
          $is_vendor = TRUE;
        }
      }
      else {
        $is_vendor = TRUE;
      }
    }

    $variables['user_is_vendor'] = $is_vendor;
  }
  else {
    $variables['user_is_vendor'] = FALSE;
  }

  // Front page specific processing.
  // Check if this is the front page.
  if (\Drupal::service('path.matcher')->isFrontPage()) {
    /* #region agent log */
    $mel_debug_log = static function (string $hypothesis_id, string $location, string $message, array $data = []): void {
      try {
        $path = dirname(DRUPAL_ROOT) . '/.cursor/debug.log';
        $payload = [
          'sessionId' => 'debug-session',
          'runId' => 'run1',
          'hypothesisId' => $hypothesis_id,
          'location' => $location,
          'message' => $message,
          'data' => $data,
          'timestamp' => (int) (microtime(TRUE) * 1000),
        ];
        file_put_contents($path, json_encode($payload) . PHP_EOL, FILE_APPEND);
      }
      catch (\Throwable $e) {
        // Ignore logging failures.
      }
    };
    $mel_debug_log('A', 'myeventlane_theme.theme:preprocess_page(front)', 'Entered front preprocess', [
      'route' => \Drupal::routeMatch()->getRouteName(),
      'is_front' => TRUE,
    ]);
    /* #endregion agent log */

    // Build above-the-cards front UI data (cached + tagged).
    try {
      /** @var \Drupal\myeventlane_core\Service\FrontCategoryStatsService $stats */
      $stats = \Drupal::service('myeventlane_core.front_category_stats');
      $data = $stats->buildFrontStats();

      $variables['mel_front'] = [
        'headline' => 'Run Your Show',
        'subline' => 'Your lane to great events.',
        'values' => [
          ['title' => 'Built for communities', 'text' => 'Simple tools to publish and manage events fast.'],
          ['title' => 'No platform fees', 'text' => 'Keep more of what you earn.'],
          ['title' => 'Inclusive by design', 'text' => 'Clear, accessible experiences for everyone.'],
        ],
        'categories' => $data['items'],
        'total' => $data['total'],
        'pie' => $data['pie'],
      ];

      // Attach the front library.
      $variables['#attached']['library'][] = 'myeventlane_theme/front';

      // Make output cacheable and properly tagged.
      $cacheable = new CacheableMetadata();
      $cacheable->setCacheMaxAge((int) $data['cache']['max_age']);
      $cacheable->setCacheTags($data['cache']['tags']);
      $cacheable->applyTo($variables);
    }
    catch (\Exception $e) {
      // Gracefully fall back if the stats service is unavailable.
    }

    // Load category terms for the homepage category buttons.
    // Prefer the vocabulary that backs /events/category/% (categories).
    $term_storage = \Drupal::entityTypeManager()->getStorage('taxonomy_term');
    $terms = [];

    try {
      $terms = $term_storage->loadTree('categories', 0, NULL, TRUE);
    }
    catch (\Exception $e) {
      // Fallback if vocabulary differs.
      try {
        $terms = $term_storage->loadTree('event_type', 0, NULL, TRUE);
      }
      catch (\Exception $e) {
        $terms = [];
      }
    }

    $categories = array_map(static function ($term) {
      $name = $term->getName();
      $key = strtolower($name);
      $key = str_replace([' ', '&'], ['-', 'and'], $key);
      $key = preg_replace('/[^a-z0-9-]/', '', $key);

      return (object) [
        'tid' => $term->id(),
        'name' => $name,
        // Matches views.view.upcoming_events.yml path: events/category/%.
        'url' => '/events/category/' . $term->id(),
        'class' => $key,
        // Alias for templates that expect machine_name.
        'machine_name' => $key,
      ];
    }, $terms);

    // New canonical variable for homepage template.
    $variables['categories'] = $categories;
    // Back-compat with older templates.
    $variables['event_categories'] = array_map(static function ($t) {
      return [
        'tid' => $t->tid,
        'name' => $t->name,
        'url' => $t->url,
      ];
    }, $categories);

    // Keep original hero headline and subheading.
    // $variables['hero_headline'] = t('Run Your Show')
    // $variables['hero_subheading'] = t('Empowering Event Creators')

    // Load category pie chart block for hero.
    try {
      $block_manager = \Drupal::service('plugin.manager.block');
      $pie_chart_block = $block_manager->createInstance('category_pie_chart_block', []);
      if ($pie_chart_block && $pie_chart_block->access(\Drupal::currentUser())) {
        $build = $pie_chart_block->build();
        if (!empty($build)) {
          $variables['hero_pie_chart'] = $build;
        }
      }
    }
    catch (\Exception $e) {
      // Pie chart block not available, continue without it.
      $variables['hero_pie_chart'] = NULL;
    }

    // Add calendar data for mini calendar.
    $variables['calendar'] = _myeventlane_theme_get_calendar_data();

    // Load and render Featured Events view.
    $featured_view = Views::getView('featured_events');
    if ($featured_view && $featured_view->access('block_featured')) {
      $featured_view->setDisplay('block_featured');
      $featured_view->preExecute();
      $featured_view->execute();
      /* #region agent log */
      $mel_debug_log('A', 'myeventlane_theme.theme:preprocess_page(front)', 'Featured events view executed', [
        'view_id' => 'featured_events',
        'display' => 'block_featured',
        'result_count' => is_array($featured_view->result ?? NULL) ? count($featured_view->result) : NULL,
      ]);
      /* #endregion agent log */
      $variables['featured_events'] = $featured_view->render();
      /* #region agent log */
      try {
        $renderer = \Drupal::service('renderer');
        // Render a COPY to avoid consuming the render array before Twig prints it.
        $copy = $variables['featured_events'];
        $html = (string) $renderer->renderPlain($copy);
        $first_tag = NULL;
        if (preg_match('/<([a-z0-9]+)\b[^>]*\bclass="[^"]*\bmel-event-card\b[^"]*"[^>]*>/i', $html, $m)) {
          $first_tag = [
            'tag' => $m[1] ?? NULL,
            'open' => $m[0] ?? NULL,
          ];
        }
        $mel_debug_log('B', 'myeventlane_theme.theme:preprocess_page(front)', 'Featured events rendered snapshot', [
          'html_len' => strlen($html),
          'count_mel_event_card' => substr_count($html, 'mel-event-card'),
          'count_views_row' => substr_count($html, 'views-row'),
          'contains_node_teaser' => (strpos($html, 'node--view-mode-teaser') !== FALSE),
          'contains_view_wrapper' => (strpos($html, 'view-featured-events') !== FALSE),
          'first_mel_event_card_tag' => $first_tag ? $first_tag['tag'] : NULL,
          'first_mel_event_card_open' => $first_tag ? $first_tag['open'] : NULL,
          'count_article' => substr_count($html, '<article'),
        ]);
      }
      catch (\Throwable $e) {
        $mel_debug_log('B', 'myeventlane_theme.theme:preprocess_page(front)', 'Featured events rendered snapshot failed', [
          'error' => $e->getMessage(),
        ]);
      }
      /* #endregion agent log */
    }
    else {
      /* #region agent log */
      $mel_debug_log('A', 'myeventlane_theme.theme:preprocess_page(front)', 'Featured events view missing or access denied', [
        'view_exists' => (bool) $featured_view,
        'access_block_featured' => $featured_view ? (bool) $featured_view->access('block_featured') : NULL,
      ]);
      /* #endregion agent log */
      $variables['featured_events'] = NULL;
    }

    // Load and render New Events view.
    $new_view = Views::getView('new_events');
    if ($new_view && $new_view->access('block_new')) {
      $new_view->setDisplay('block_new');
      $new_view->preExecute();
      $new_view->execute();
      $variables['new_events'] = $new_view->render();
    }
    else {
      $variables['new_events'] = NULL;
    }

    // Render value proposition block.
    try {
      $block_manager = \Drupal::service('plugin.manager.block');
      $value_prop_block = $block_manager->createInstance('myeventlane_value_proposition', []);
      if ($value_prop_block && $value_prop_block->access(\Drupal::currentUser())) {
        $build = $value_prop_block->build();
        if (!empty($build)) {
          $variables['value_proposition'] = $build;
        }
      }
    }
    catch (\Exception $e) {
      // Block not available, continue without it.
      $variables['value_proposition'] = NULL;
    }

    // Render category pie chart block.
    try {
      $block_manager = \Drupal::service('plugin.manager.block');
      $pie_chart_block = $block_manager->createInstance('category_pie_chart_block', []);
      if ($pie_chart_block && $pie_chart_block->access(\Drupal::currentUser())) {
        $build = $pie_chart_block->build();
        if (!empty($build)) {
          $variables['category_pie_chart'] = $build;
        }
      }
    }
    catch (\Exception $e) {
      // Block not available, continue without it.
      $variables['category_pie_chart'] = NULL;
    }

    // Add theme directory path for feature block icons.
    $theme_handler = \Drupal::service('extension.list.theme');
    $theme_path = $theme_handler->getPath('myeventlane_theme');
    $variables['theme_directory'] = '/' . $theme_path;

    // Add hero positioning variables (for platform messaging).
    $current_user = \Drupal::currentUser();
    $is_logged_in = $current_user->isAuthenticated();

    // Determine create event URL based on login status.
    $create_event_url = '/create-event';
    if ($is_logged_in) {
      // Check if user has vendor: if so, route to dashboard, otherwise to /node/add/event.
      $uid = (int) $current_user->id();
      $has_vendor = FALSE;
      if (\Drupal::moduleHandler()->moduleExists('myeventlane_vendor')) {
        $vendor_storage = \Drupal::entityTypeManager()->getStorage('myeventlane_vendor');
        $vendor_ids = $vendor_storage->getQuery()
          ->accessCheck(TRUE)
          ->condition('uid', $uid)
          ->range(0, 1)
          ->execute();
        if (empty($vendor_ids)) {
          $vendor_ids = $vendor_storage->getQuery()
            ->accessCheck(TRUE)
            ->condition('field_vendor_users', $uid)
            ->range(0, 1)
            ->execute();
        }
        $has_vendor = !empty($vendor_ids);
      }
      $create_event_url = $has_vendor ? '/vendor/dashboard' : '/node/add/event';
    }

    // Only set default hero values if NOT on front page (front page has its own values).
    if (!\Drupal::service('path.matcher')->isFrontPage()) {
      $variables['hero_headline'] = t('Your lane to great events.');
      $variables['hero_subheading'] = t('Create, share, and celebrate local stories.');
    }
    $variables['hero_badges'] = [
      t('Free to list'),
      t('Community-first'),
      t('Run your show, your way'),
    ];
    $variables['hero_primary_cta'] = [
      'text' => t('Create your event'),
      'url' => $create_event_url,
    ];
    $variables['hero_secondary_cta'] = [
      'text' => t('Explore events'),
      'url' => '/events',
    ];
  }

  // Make category pills data available to listing page headers (taxonomy, search, filtered listings).
  // This is pure data; Twig handles the presentation.
  _myeventlane_theme_attach_mel_header_categories($variables);
}

/**
 * Helper function to generate calendar data.
 */
function _myeventlane_theme_get_calendar_data($year = NULL, $month = NULL): array {
  $year = $year ?: date('Y');
  $month = $month ?: date('n');

  $first_day = mktime(0, 0, 0, $month, 1, $year);
  $days_in_month = date('t', $first_day);
  // 0 = Sunday.
  $start_day = date('w', $first_day);

  // Get events for this month.
  $start_date = date('Y-m-01', $first_day);
  $end_date = date('Y-m-t', $first_day);

  $query = \Drupal::entityQuery('node')
    ->condition('type', 'event')
    ->condition('status', 1)
    ->condition('field_event_start', $start_date, '>=')
    ->condition('field_event_start', $end_date . 'T23:59:59', '<=')
    ->accessCheck(TRUE);

  $nids = $query->execute();
  $events_by_day = [];

  if (!empty($nids)) {
    $nodes = \Drupal::entityTypeManager()->getStorage('node')->loadMultiple($nids);
    foreach ($nodes as $node) {
      $event_date = $node->get('field_event_start')->value;
      $day = (int) date('j', strtotime($event_date));
      if (!isset($events_by_day[$day])) {
        $events_by_day[$day] = [];
      }
      $events_by_day[$day][] = [
        'title' => $node->label(),
        'url' => $node->toUrl()->toString(),
      ];
    }
  }

  return [
    'year' => $year,
    'month' => $month,
    'month_name' => date('F', $first_day),
    'days_in_month' => $days_in_month,
    'start_day' => $start_day,
    'today' => (int) date('j'),
    'is_current_month' => ($year == date('Y') && $month == date('n')),
    'events_by_day' => $events_by_day,
  ];
}

/**
 * Implements hook_preprocess_page() for category pages.
 *
 * Adds category info and all categories for the hero section.
 */
function myeventlane_theme_preprocess_page__events__category(array &$variables): void {
  // Get the category term ID from the URL.
  $tid = \Drupal::routeMatch()->getParameter('arg_0');

  if ($tid) {
    $term = \Drupal::entityTypeManager()->getStorage('taxonomy_term')->load($tid);
    if ($term) {
      $variables['current_category'] = [
        'tid' => $term->id(),
        'name' => $term->label(),
      ];
    }
  }

  // Load all categories for the hero chips.
  $term_storage = \Drupal::entityTypeManager()->getStorage('taxonomy_term');
  $terms = $term_storage->loadByProperties(['vid' => 'categories']);

  $categories = [];
  foreach ($terms as $term) {
    $categories[] = [
      'tid' => $term->id(),
      'name' => $term->label(),
      'url' => '/events/category/' . $term->id(),
    ];
  }

  $variables['event_categories'] = $categories;
}

/**
 * Implements hook_preprocess_page() for calendar page.
 */
function myeventlane_theme_preprocess_page__calendar(array &$variables): void {
  // Load all published events for the calendar.
  $query = \Drupal::entityQuery('node')
    ->condition('type', 'event')
    ->condition('status', 1)
    ->accessCheck(TRUE);

  $nids = $query->execute();
  $events = [];

  if (!empty($nids)) {
    $nodes = \Drupal::entityTypeManager()->getStorage('node')->loadMultiple($nids);

    // Category colors.
    $category_colors = [
      'music' => '#7c5cff',
      'sports' => '#ff6f61',
      'food' => '#ffd46f',
      'arts' => '#4ecdc4',
      'business' => '#1a1a2e',
      'community' => '#ff6f61',
      'education' => '#4ecdc4',
      'charity' => '#ff6f61',
    ];

    foreach ($nodes as $node) {
      $start = $node->get('field_event_start')->value;
      $end = $node->hasField('field_event_end') ? $node->get('field_event_end')->value : NULL;

      // Get category color.
      $color = '#7c5cff';
      if ($node->hasField('field_category') && !$node->get('field_category')->isEmpty()) {
        $category = $node->get('field_category')->entity;
        if ($category) {
          $cat_name = strtolower($category->label());
          $color = $category_colors[$cat_name] ?? '#7c5cff';
        }
      }

      if ($start) {
        $events[] = [
          'title' => $node->label(),
          'start' => $start,
          'end' => $end,
          'url' => $node->toUrl()->toString(),
          'color' => $color,
        ];
      }
    }
  }

  $variables['calendar_events'] = $events;
}

/**
 * Implements hook_preprocess_taxonomy_term().
 *
 * Provides the MEL header category pills data to taxonomy term templates.
 */
function myeventlane_theme_preprocess_taxonomy_term(array &$variables): void {
  _myeventlane_theme_attach_mel_header_categories($variables);
}

/**
 * Attaches MEL header category pills data to a variables array.
 *
 * @param array $variables
 *   Preprocess variables array (page, taxonomy term, etc).
 */
function _myeventlane_theme_attach_mel_header_categories(array &$variables): void {
  // Avoid overwriting if something upstream already provided it.
  if (isset($variables['mel_header_categories'])) {
    return;
  }

  try {
    /** @var \Drupal\myeventlane_core\Service\FrontCategoryStatsService $stats */
    $stats = \Drupal::service('myeventlane_core.front_category_stats');
    $data = $stats->buildFrontStats();

    $variables['mel_header_categories'] = $data['items'] ?? [];

    $cacheable = new CacheableMetadata();
    $cacheable->setCacheMaxAge((int) ($data['cache']['max_age'] ?? 3600));
    $cacheable->setCacheTags((array) ($data['cache']['tags'] ?? []));
    $cacheable->applyTo($variables);
  }
  catch (\Exception $e) {
    $variables['mel_header_categories'] = [];
  }
}

/**
 * Implements hook_library_info_alter().
 *
 * Dynamically rewrites the 'global-styling' library to point to the current
 * Vite-built CSS file defined in the manifest. This allows hashed filenames
 * generated by Vite (e.g. main.BMgQme3h.css) to be used automatically.
 * Also redirects myeventlane_event/event_wizard CSS to theme location.
 */
function myeventlane_theme_library_info_alter(array &$libraries, string $extension): void {
  // Handle theme's own libraries.
  if ($extension === 'myeventlane_theme') {
    // Ensure our library exists before altering it.
    if (!isset($libraries['global-styling'])) {
      return;
    }

    $css_path = _myeventlane_theme_manifest_css();
    if (!$css_path) {
      // Gracefully fallback to whatever the .libraries.yml defines.
      return;
    }

    // Replace the existing CSS with only the hashed Vite output.
    $libraries['global-styling']['css']['theme'] = [
      $css_path => [],
    ];
  }

}

/**
 * Reads the Vite manifest and returns the primary CSS file.
 *
 * @return string|null
 *   Relative path to the CSS file (e.g. 'dist/assets/main.ABC123.css'),
 *   or NULL if the manifest or asset cannot be read.
 */
function _myeventlane_theme_manifest_css(): ?string {
  static $cached = NULL;

  // Return cached value if already processed.
  if ($cached !== NULL) {
    return $cached;
  }

  // Load the theme path.
  $theme_handler = \Drupal::service('extension.list.theme');
  $relative_theme_path = $theme_handler->getPath('myeventlane_theme');

  // Vite manifest path.
  $manifest_path = DRUPAL_ROOT . '/' . $relative_theme_path . '/dist/.vite/manifest.json';
  if (!file_exists($manifest_path)) {
    return $cached = NULL;
  }

  $json = file_get_contents($manifest_path);
  if (!$json) {
    return $cached = NULL;
  }

  $manifest = json_decode($json, TRUE);
  if (!is_array($manifest)) {
    return $cached = NULL;
  }

  // Vite default entry: js/main.js → CSS array.
  if (empty($manifest['js/main.js']['css'][0])) {
    return $cached = NULL;
  }

  // Build theme-relative path.
  $css = $manifest['js/main.js']['css'][0];
  $css = ltrim($css, '/');
  
  // If CSS is just 'main.css', return 'dist/main.css'.
  // If it's already a full path, return it as-is.
  if (!str_starts_with($css, 'dist/')) {
    return $cached = "dist/{$css}";
  }
  
  return $cached = $css;
}


/**
 * Implements hook_node_view_alter().
 *
 * Attaches libraries and modifies build for event nodes.
 * Prevents default field rendering so our custom template has full control.
 */
function myeventlane_theme_node_view_alter(array &$build, \Drupal\Core\Entity\EntityInterface $entity, \Drupal\Core\Entity\Display\EntityViewDisplayInterface $display): void {
  // Only process event nodes in full/default view modes.
  if (!$entity instanceof \Drupal\node\NodeInterface || $entity->bundle() !== 'event') {
    return;
  }

  $view_mode = $build['#view_mode'] ?? 'full';
  if (!in_array($view_mode, ['full', 'default'], TRUE)) {
    return;
  }

  // Our custom field templates handle field rendering without default wrappers.
  // Fields remain accessible in content array and will use our custom field templates.

  // Attach event-page library for styling.
  $build['#attached']['library'][] = 'myeventlane_theme/event-page';
  
  // Add mel-event class for SCSS styling to apply.
  if (!isset($build['#attributes'])) {
    $build['#attributes'] = [];
  }
  if (!isset($build['#attributes']['class'])) {
    $build['#attributes']['class'] = [];
  }
  if (!in_array('mel-event', $build['#attributes']['class'], TRUE)) {
    $build['#attributes']['class'][] = 'mel-event';
  }
}

/**
 * Implements hook_preprocess_node().
 */
function myeventlane_theme_preprocess_node(array &$variables): void {
  if (empty($variables['node']) || !$variables['node'] instanceof NodeInterface) {
    return;
  }

  $node = $variables['node'];
  if ($node->bundle() !== 'event') {
    return;
  }

  $view_mode = (string) ($variables['view_mode'] ?? '');

  // Handle form view mode.
  if ($view_mode === 'form' || (isset($variables['form']) && $variables['form'])) {
    $variables['attributes']['class'][] = 'mel-node-form';
    $variables['attributes']['class'][] = 'mel-node-form--event';
    $variables['theme_hook_suggestions'][] = 'node__event__form';
    return;
  }

  // Process teaser view mode for event cards in Views.
  if ($view_mode === 'teaser') {
    // Check if we're in a featured_events view context.
    $view = NULL;
    // Try to get view from various possible contexts.
    if (isset($variables['view'])) {
      $view = $variables['view'];
    }
    elseif (function_exists('views_get_current_view')) {
      $view = views_get_current_view();
    }
    
    if ($view instanceof ViewExecutable && $view->id() === 'featured_events') {
      $variables['mel_card_variant'] = 'featured';
    }
    // Return early for teaser - let the template handle the rest.
    return;
  }

  // Only process full/default view modes for event display.
  if (!in_array($view_mode, ['full', 'default'], TRUE)) {
    return;
  }

  // Add template suggestion to ensure our custom template is used.
  if (!isset($variables['theme_hook_suggestions'])) {
    $variables['theme_hook_suggestions'] = [];
  }
  // Add our custom template suggestion at the beginning (highest priority).
  array_unshift($variables['theme_hook_suggestions'], 'node__event__' . $view_mode);
  array_unshift($variables['theme_hook_suggestions'], 'node__event');

  // Ensure mel-event class is in attributes.
  if (!in_array('mel-event', $variables['attributes']['class'] ?? [], TRUE)) {
    $variables['attributes']['class'][] = 'mel-event';
  }

  $variables['#attached']['library'][] = 'myeventlane_theme/myeventlane_event_full';

  // Clean title string.
  $variables['mel_title'] = (string) $node->label();

  // Venue name.
  $venue = '';
  if ($node->hasField('field_venue_name') && !$node->get('field_venue_name')->isEmpty()) {
    $venue = (string) $node->get('field_venue_name')->value;
  }
  elseif ($node->hasField('field_event_venue') && !$node->get('field_event_venue')->isEmpty()) {
    $venue = (string) $node->get('field_event_venue')->value;
  }
  $variables['mel_venue'] = trim($venue);

  // Address (single string, for map card only).
  $address = '';
  if ($node->hasField('field_location') && !$node->get('field_location')->isEmpty()) {
    $item = $node->get('field_location')->first();
    if ($item) {
      $v = $item->getValue();
      $parts = [];

      if (!empty($v['address_line1'])) {
        $parts[] = (string) $v['address_line1'];
      }
      if (!empty($v['locality'])) {
        $parts[] = (string) $v['locality'];
      }

      $state_post = [];
      if (!empty($v['administrative_area'])) {
        $state_post[] = (string) $v['administrative_area'];
      }
      if (!empty($v['postal_code'])) {
        $state_post[] = (string) $v['postal_code'];
      }
      if ($state_post) {
        $parts[] = implode(' ', $state_post);
      }

      if (!empty($v['country_code'])) {
        $parts[] = (string) $v['country_code'];
      }

      $address = trim(implode(', ', array_filter($parts)));
    }
  }
  elseif ($node->hasField('field_event_address') && !$node->get('field_event_address')->isEmpty()) {
    $address = (string) $node->get('field_event_address')->value;
  }
  $variables['mel_address'] = trim($address);

  // Coordinates for map only.
  $lat = NULL;
  $lng = NULL;

  if ($node->hasField('field_location_latitude') && !$node->get('field_location_latitude')->isEmpty()) {
    $lat = (float) $node->get('field_location_latitude')->value;
  }
  elseif ($node->hasField('field_event_lat') && !$node->get('field_event_lat')->isEmpty()) {
    $lat = (float) $node->get('field_event_lat')->value;
  }

  if ($node->hasField('field_location_longitude') && !$node->get('field_location_longitude')->isEmpty()) {
    $lng = (float) $node->get('field_location_longitude')->value;
  }
  elseif ($node->hasField('field_event_lng') && !$node->get('field_event_lng')->isEmpty()) {
    $lng = (float) $node->get('field_event_lng')->value;
  }

  $variables['mel_lat'] = $lat;
  $variables['mel_lng'] = $lng;

  // Attach map JS library when coords exist.
  // Note: myeventlane_location module also attaches via hook_page_attachments,
  // but we ensure it here as well for reliability.
  if ($lat !== NULL && $lng !== NULL) {
    $variables['#attached']['library'][] = 'myeventlane_location/event_map';
    
    // Ensure drupalSettings are set for map JS (backup if myeventlane_location doesn't set them).
    if (!isset($variables['#attached']['drupalSettings'])) {
      $variables['#attached']['drupalSettings'] = [];
    }
    if (!isset($variables['#attached']['drupalSettings']['myeventlaneLocationEvent'])) {
      try {
        /** @var \Drupal\myeventlane_location\Service\LocationProviderManager $provider_manager */
        $provider_manager = \Drupal::service('myeventlane_location.provider_manager');
        $settings = $provider_manager->getFrontendSettings();
        $variables['#attached']['drupalSettings']['myeventlaneLocation'] = $settings;
        $variables['#attached']['drupalSettings']['myeventlaneLocationEvent'] = [
          'latitude' => $lat,
          'longitude' => $lng,
          'title' => $variables['mel_title'],
        ];
      }
      catch (\Exception $e) {
        // Service unavailable, continue without drupalSettings.
      }
    }
  }
  
  // Add ticket CTA via EventModeManager.
  try {
    /** @var \Drupal\myeventlane_event\Service\EventModeManager $mode_manager */
    $mode_manager = \Drupal::service('myeventlane_event.mode_manager');
    $primary_cta = $mode_manager->getPrimaryCta($node);
    if ($primary_cta) {
      $variables['content']['mel_ticket_cta'] = $primary_cta;
    }
    
    // Get all CTAs for templates that need them.
    $all_ctas = $mode_manager->getAllCtas($node);
    $variables['mel_all_ctas'] = $all_ctas;
    $variables['mel_event_mode'] = $mode_manager->getEffectiveMode($node);
    $variables['mel_is_bookable'] = $mode_manager->isBookable($node);
  }
  catch (\Exception $e) {
    // Service unavailable, continue without ticket CTA.
    $variables['mel_all_ctas'] = [];
    $variables['mel_event_mode'] = 'none';
    $variables['mel_is_bookable'] = FALSE;
  }

  // Get event state for state badge display.
  try {
    /** @var \Drupal\myeventlane_event_state\Service\EventStateResolverInterface $state_resolver */
    $state_resolver = \Drupal::service('myeventlane_event_state.resolver');
    $state = $state_resolver->resolveState($node);
    $variables['mel_event_state'] = $state;
    
    // Get sales start/end for display.
    $sales_start = $state_resolver->getSalesStart($node);
    $sales_end = $state_resolver->getSalesEnd($node);
    $variables['mel_sales_start'] = $sales_start;
    $variables['mel_sales_end'] = $sales_end;
    
    // Format sales start date if scheduled.
    if ($state === 'scheduled' && $sales_start) {
      $variables['mel_sales_start_formatted'] = \Drupal::service('date.formatter')->format($sales_start, 'custom', 'l j F Y g:ia');
    }
  }
  catch (\Exception $e) {
    // Service unavailable, default to draft state.
    $variables['mel_event_state'] = 'draft';
    $variables['mel_sales_start'] = NULL;
    $variables['mel_sales_end'] = NULL;
    $variables['mel_sales_start_formatted'] = NULL;
  }

  // Get capacity information for sidebar display.
  try {
    /** @var \Drupal\myeventlane_metrics\Service\EventMetricsServiceInterface $metrics_service */
    $metrics_service = \Drupal::service('myeventlane_metrics.service');
    $capacity = $metrics_service->getCapacityTotal($node);
    $attendee_count = $metrics_service->getAttendeeCount($node);
    $remaining = $metrics_service->getRemainingCapacity($node);
    
    $variables['mel_capacity'] = [
      'capacity' => $capacity,
      'attendee_count' => $attendee_count,
      'remaining' => $remaining,
    ];
  }
  catch (\Exception $e) {
    // Metrics service unavailable, skip capacity display.
    $variables['mel_capacity'] = NULL;
  }

  // Vendor information (prefer field_event_vendor, fallback to other vendor fields).
  $vendor_entity = NULL;
  $vendor_name = '';
  $vendor_logo = NULL;
  
  // Check field_event_vendor first (preferred).
  if ($node->hasField('field_event_vendor') && !$node->get('field_event_vendor')->isEmpty()) {
    $vendor_entity = $node->get('field_event_vendor')->entity;
  }
  // Fallback to other vendor fields.
  else {
    foreach (['field_vendor', 'field_vendor_target', 'field_store'] as $f) {
      if ($node->hasField($f) && !$node->get($f)->isEmpty()) {
        $ref = $node->get($f)->entity;
        if ($ref && $ref->getEntityTypeId() === 'myeventlane_vendor') {
          $vendor_entity = $ref;
          break;
        }
      }
    }
  }
  
  if ($vendor_entity) {
    $vendor_name = (string) $vendor_entity->label();
    // Get vendor logo if available.
    if ($vendor_entity->hasField('field_vendor_logo') && !$vendor_entity->get('field_vendor_logo')->isEmpty()) {
      $logo_file = $vendor_entity->get('field_vendor_logo')->entity;
      if ($logo_file) {
        try {
          $vendor_logo = \Drupal::service('file_url_generator')->generateString($logo_file->getFileUri());
        }
        catch (\Exception $e) {
          // Logo unavailable, continue without it.
        }
      }
    }
  }
  
  $variables['mel_vendor'] = trim($vendor_name);
  $variables['mel_vendor_entity'] = $vendor_entity;
  $variables['mel_vendor_logo'] = $vendor_logo;

  // Category pills.
  $cats = [];
  foreach (['field_category', 'field_categories', 'field_event_category'] as $f) {
    if ($node->hasField($f) && !$node->get($f)->isEmpty()) {
      foreach ($node->get($f)->referencedEntities() as $term) {
        if (!$term instanceof TermInterface) {
          continue;
        }
        $color = '';
        foreach (['field_color', 'field_colour', 'field_mel_color'] as $cf) {
          if ($term->hasField($cf) && !$term->get($cf)->isEmpty()) {
            $color = (string) $term->get($cf)->value;
            break;
          }
        }
        $cats[] = [
          'tid' => (int) $term->id(),
          'name' => (string) $term->label(),
          'color' => trim($color),
        ];
      }
      break;
    }
  }
  $variables['mel_categories'] = $cats;

  // ============================================================================
  // NEW EVENT PAGE VARIABLES (for expanded card layout)
  // ============================================================================

  // State variables (normalized from mel_event_state).
  $state = $variables['mel_event_state'] ?? 'draft';
  $variables['mel_state'] = $state;

  // State label mapping.
  $state_labels = [
    'scheduled' => t('Scheduled'),
    'live' => t('Live'),
    'sold_out' => t('Sold Out'),
    'cancelled' => t('Cancelled'),
    'ended' => t('Ended'),
    'draft' => t('Draft'),
  ];
  $variables['mel_state_label'] = $state_labels[$state] ?? t('Draft');

  // Status message with MEL tone.
  $status_message = NULL;
  if ($state === 'cancelled') {
    $status_message = t('This event won\'t be going ahead.');
  }
  elseif ($state === 'scheduled' && isset($variables['mel_sales_start_formatted'])) {
    $status_message = t('Sales open on @date. Add it to your calendar so you don\'t miss out.', [
      '@date' => $variables['mel_sales_start_formatted'],
    ]);
  }
  elseif ($state === 'sold_out') {
    $status_message = t('Sold out — join the waitlist and we\'ll notify you.');
  }
  $variables['mel_status_message'] = $status_message;

  // Date and time labels.
  $date_formatter = \Drupal::service('date.formatter');
  $date_label = NULL;
  $time_label = NULL;

  if ($node->hasField('field_event_start') && !$node->get('field_event_start')->isEmpty()) {
    $start_value = $node->get('field_event_start')->value;
    $start_timestamp = strtotime($start_value);

    $date_label = $date_formatter->format($start_timestamp, 'custom', 'l j F Y');
    $time_label = $date_formatter->format($start_timestamp, 'custom', 'g:ia');

    if ($node->hasField('field_event_end') && !$node->get('field_event_end')->isEmpty()) {
      $end_value = $node->get('field_event_end')->value;
      $end_timestamp = strtotime($end_value);
      $time_label .= ' – ' . $date_formatter->format($end_timestamp, 'custom', 'g:ia');
    }
  }
  $variables['mel_date_label'] = $date_label;
  $variables['mel_time_label'] = $time_label;

  // Venue label (prefer venue name, fallback to address locality).
  $venue_label = NULL;
  if (!empty($variables['mel_venue'])) {
    $venue_label = $variables['mel_venue'];
  }
  elseif (!empty($variables['mel_address'])) {
    $address_parts = explode(',', $variables['mel_address']);
    $venue_label = trim($address_parts[0] ?? '');
  }
  $variables['mel_venue_label'] = $venue_label;

  // Category label (first category only).
  $category_label = NULL;
  if (!empty($cats) && isset($cats[0]['name'])) {
    $category_label = $cats[0]['name'];
  }
  $variables['mel_category_label'] = $category_label;

  // ============================================================================
  // CANONICAL EVENT CTA LOGIC (Phase 1)
  // ============================================================================
  // Resolves to ONE state: Buy tickets, RSVP, Sold out, or Event ended
  // Considers: event date (past vs upcoming), capacity, ticket availability, RSVP enabled
  
  $event_cta = [
    'label' => NULL,
    'url' => NULL,
    'disabled' => TRUE,
    'state' => $state,
    'helper' => NULL,
  ];

  // Event ended or cancelled - no CTA
  if ($state === 'ended' || $state === 'cancelled') {
    $event_cta['label'] = $state === 'ended' ? t('Event Ended') : t('Event Cancelled');
    $event_cta['disabled'] = TRUE;
  }
  // Scheduled (sales not started yet)
  elseif ($state === 'scheduled') {
    $event_cta['label'] = isset($variables['mel_sales_start_formatted'])
      ? t('Sales open on @date', ['@date' => $variables['mel_sales_start_formatted']])
      : t('Sales opening soon');
    $event_cta['disabled'] = TRUE;
    $event_cta['helper'] = t('Add it to your calendar so you don\'t miss out.');
  }
  // Sold out
  elseif ($state === 'sold_out') {
    // Check if waitlist is available
    if (!empty($variables['mel_all_ctas']['waitlist'])) {
      try {
        $event_cta['label'] = t('Join Waitlist');
        $event_cta['url'] = Url::fromRoute('myeventlane_event_attendees.waitlist_signup', ['node' => $node->id()])->toString();
        $event_cta['disabled'] = FALSE;
        $event_cta['helper'] = t('We\'ll notify you if a spot opens.');
      }
      catch (\Exception $e) {
        // Route not available, show sold out
        $event_cta['label'] = t('Sold Out');
        $event_cta['disabled'] = TRUE;
      }
    }
    else {
      $event_cta['label'] = t('Sold Out');
      $event_cta['disabled'] = TRUE;
    }
  }
  // Live event - determine primary action
  elseif ($state === 'live' || ($state !== 'cancelled' && $state !== 'ended')) {
    // Use EventModeManager to get primary CTA
    try {
      /** @var \Drupal\myeventlane_event\Service\EventModeManager $mode_manager */
      $mode_manager = \Drupal::service('myeventlane_event.mode_manager');
      $primary_cta = $mode_manager->getPrimaryCta($node);
      
      if (!empty($primary_cta) && isset($primary_cta['#url'])) {
        $event_cta['label'] = $primary_cta['#title'] ?? t('Get Tickets');
        $event_cta['url'] = $primary_cta['#url']->toString();
        $event_cta['disabled'] = FALSE;
      }
      // Fallback to mel_all_ctas if primary CTA not available
      elseif (!empty($variables['mel_all_ctas'])) {
        if (isset($variables['mel_all_ctas']['tickets'])) {
          $event_cta['label'] = t('Buy Tickets');
          $event_cta['url'] = Url::fromRoute('myeventlane_commerce.event_book', ['node' => $node->id()])->toString();
          $event_cta['disabled'] = FALSE;
        }
        elseif (isset($variables['mel_all_ctas']['rsvp'])) {
          $event_cta['label'] = t('RSVP Now');
          $event_cta['url'] = Url::fromRoute('myeventlane_commerce.event_book', ['node' => $node->id()])->toString();
          $event_cta['disabled'] = FALSE;
        }
        elseif (isset($variables['mel_all_ctas']['external'])) {
          $event_cta['label'] = t('Get Tickets');
          $external_url = $variables['mel_all_ctas']['external']['#url'] ?? NULL;
          if ($external_url instanceof \Drupal\Core\Url) {
            $event_cta['url'] = $external_url->toString();
            $event_cta['disabled'] = FALSE;
          }
        }
      }
      // Final fallback to content render array
      elseif (isset($variables['content']['mel_ticket_cta'])) {
        $cta_render = $variables['content']['mel_ticket_cta'];
        if (isset($cta_render['#url'])) {
          $event_cta['label'] = $cta_render['#title'] ?? t('Get Tickets');
          $event_cta['url'] = $cta_render['#url']->toString();
          $event_cta['disabled'] = FALSE;
        }
      }
    }
    catch (\Exception $e) {
      // Service unavailable, default to disabled
      $event_cta['label'] = t('Registration unavailable');
      $event_cta['disabled'] = TRUE;
    }
  }

  // Set canonical event_cta variable (primary)
  $variables['event_cta'] = $event_cta;

  // Backward compatibility: set individual variables and mel_event_cta
  $variables['mel_cta_state'] = $event_cta['disabled'] ? 'disabled' : 'enabled';
  $variables['mel_cta_label'] = $event_cta['label'];
  $variables['mel_cta_url'] = $event_cta['url'];
  $variables['mel_cta_helper'] = $event_cta['helper'];
  $variables['mel_event_cta'] = $event_cta;

  // Calendar URLs.
  $ics_url = NULL;
  $google_cal_url = NULL;

  if ($node->hasField('field_event_start') && !$node->get('field_event_start')->isEmpty()) {
    // ICS download URL.
    try {
      $ics_url = Url::fromRoute('myeventlane_rsvp.ics_download', ['node' => $node->id()])->toString();
    }
    catch (\Exception $e) {
      // Route not available.
    }

    // Google Calendar URL.
    $start_value = $node->get('field_event_start')->value;
    $end_value = $node->hasField('field_event_end') && !$node->get('field_event_end')->isEmpty()
      ? $node->get('field_event_end')->value
      : NULL;

    $start_iso = gmdate('Ymd\THis\Z', strtotime($start_value));
    $end_iso = $end_value ? gmdate('Ymd\THis\Z', strtotime($end_value)) : gmdate('Ymd\THis\Z', strtotime($start_value . ' +2 hours'));

    $title_encoded = rawurlencode($node->label());
    $location_parts = array_filter([$variables['mel_venue'] ?? NULL, $variables['mel_address'] ?? NULL]);
    $location_encoded = rawurlencode(implode(', ', $location_parts));
    $details_encoded = rawurlencode(strip_tags($node->hasField('body') && !$node->get('body')->isEmpty() ? $node->get('body')->value : ''));
    $url_encoded = rawurlencode($node->toUrl('canonical', ['absolute' => TRUE])->toString());

    $google_cal_url = "https://calendar.google.com/calendar/render?action=TEMPLATE"
      . "&text={$title_encoded}"
      . "&dates={$start_iso}/{$end_iso}"
      . "&details={$details_encoded}"
      . "&location={$location_encoded}"
      . "&ctz=" . date_default_timezone_get();
  }

  $variables['mel_ics_url'] = $ics_url;
  $variables['mel_google_cal_url'] = $google_cal_url;

  // Directions URL.
  $directions_url = NULL;
  if (!empty($variables['mel_address'])) {
    $directions_url = 'https://maps.google.com/?q=' . rawurlencode($variables['mel_address']);
  }
  elseif (!empty($variables['mel_venue'])) {
    $directions_url = 'https://maps.google.com/?q=' . rawurlencode($variables['mel_venue']);
  }
  $variables['mel_directions_url'] = $directions_url;

  // Capacity variables.
  $attending_count = 0;
  $capacity_percent = 0;
  $capacity_helper = NULL;

  if (!empty($variables['mel_capacity'])) {
    $attending_count = (int) ($variables['mel_capacity']['attendee_count'] ?? 0);
    $capacity = $variables['mel_capacity']['capacity'] ?? NULL;
    $remaining = $variables['mel_capacity']['remaining'] ?? NULL;

    if ($capacity !== NULL && $capacity > 0) {
      $capacity_percent = min(100, round(($attending_count / $capacity) * 100));
      if ($remaining !== NULL) {
        $capacity_helper = t('@count spots remaining', ['@count' => $remaining]);
      }
    }
    else {
      $capacity_percent = 0;
      $capacity_helper = t('Unlimited capacity');
    }
  }

  $variables['mel_attending_count'] = $attending_count;
  $variables['mel_capacity_percent'] = $capacity_percent;
  $variables['mel_capacity_helper'] = $capacity_helper;

  // Price summary (Free RSVP or From $X for paid events).
  $price_summary = NULL;
  $event_type = $node->hasField('field_event_type') && !$node->get('field_event_type')->isEmpty()
    ? (string) $node->get('field_event_type')->value
    : 'rsvp';
  
  // Check if event has paid tickets.
  if (in_array($event_type, ['paid', 'both'], TRUE)) {
    // Get product and find lowest price variation.
    if ($node->hasField('field_product_target') && !$node->get('field_product_target')->isEmpty()) {
      $product = $node->get('field_product_target')->entity;
      if ($product && $product->isPublished()) {
        $variations = $product->getVariations();
        $lowest_price = NULL;
        
        foreach ($variations as $variation) {
          if (!$variation->isPublished()) {
            continue;
          }
          
          $price = $variation->getPrice();
          if ($price) {
            $price_number = $price->getNumber();
            // Only consider non-zero prices for "From $X" display.
            if ($price_number > 0) {
              if ($lowest_price === NULL || $price_number < $lowest_price->getNumber()) {
                $lowest_price = $price;
              }
            }
          }
        }
        
        if ($lowest_price) {
          try {
            $currency_formatter = \Drupal::service('commerce_price.currency_formatter');
            $formatted_price = $currency_formatter->format($lowest_price->getNumber(), $lowest_price->getCurrencyCode());
            $price_summary = t('From @price', ['@price' => $formatted_price]);
          }
          catch (\Exception $e) {
            // Currency formatter unavailable, skip price summary.
          }
        }
        // If all variations are $0, show "Free RSVP" for both mode.
        elseif ($event_type === 'both') {
          $price_summary = t('Free RSVP');
        }
      }
    }
  }
  // RSVP-only events are free.
  elseif ($event_type === 'rsvp') {
    $price_summary = t('Free RSVP');
  }
  
  $variables['mel_price_summary'] = $price_summary;

  // Organiser block (prefer vendor, fallback to node owner).
  $organiser_block = [];
  $organiser_name = NULL;
  $organiser_logo = NULL;
  
  // Use vendor if available.
  if ($vendor_entity) {
    $organiser_name = $vendor_name;
    $organiser_logo = $vendor_logo;
  }
  // Fallback to node owner.
  else {
    $owner = $node->getOwner();
    if ($owner) {
      $organiser_name = $owner->getDisplayName();
    }
  }
  
  if ($organiser_name) {
    $markup = '<div class="mel-organiser__name">' . htmlspecialchars($organiser_name, ENT_QUOTES, 'UTF-8') . '</div>';
    if ($organiser_logo) {
      $markup = '<div class="mel-organiser__logo"><img src="' . htmlspecialchars($organiser_logo, ENT_QUOTES, 'UTF-8') . '" alt="' . htmlspecialchars($organiser_name, ENT_QUOTES, 'UTF-8') . '" /></div>' . $markup;
    }
    $markup .= '<p class="mel-organiser__trust">Verified organiser</p>';
    
    $organiser_block = [
      '#type' => 'markup',
      '#markup' => $markup,
    ];
  }
  $variables['mel_organiser_block'] = $organiser_block;
  $variables['mel_organiser_name'] = $organiser_name;
  $variables['mel_organiser_logo'] = $organiser_logo;

  // ============================================================================
  // ADDITIONAL EVENT FULL TEMPLATE VARIABLES
  // ============================================================================
  // These variables complement the canonical event_cta variable above.
  // They're used by node--event--full.html.twig template.

  // Registration badge (for backward compatibility with existing templates).
  $variables['mel_registration_badge'] = _myeventlane_theme_event_registration_badge($node);

  // Capacity text (simple string format) - for backward compatibility.
  $variables['mel_capacity_text'] = _myeventlane_theme_event_capacity_text($node);

  // Calendar links are already set above (mel_ics_url, mel_google_cal_url).
  // The helper function below is kept for backward compatibility but not used by full template.

  // Optional blocks (wire later if needed).
  $variables['mel_host_block'] = NULL;
  $variables['mel_more_from_host_block'] = NULL;
  $variables['mel_trending_block'] = NULL;
}

/**
 * Implements hook_preprocess_user().
 *
 * Adds classes and context for user forms (login, register, password, edit).
 */
function myeventlane_theme_preprocess_user(array &$variables): void {
  $user = $variables['user'];
  $view_mode = $variables['view_mode'] ?? 'full';

  // Only process form view modes.
  if ($view_mode !== 'form' && $view_mode !== 'default') {
    return;
  }

  $variables['attributes']['class'][] = 'mel-user-form';
}

/**
 * Implements hook_preprocess_entity().
 *
 * Adds classes and context for vendor entity forms.
 */
function myeventlane_theme_preprocess_entity(array &$variables): void {
  $entity = $variables['entity'];
  $view_mode = $variables['view_mode'] ?? 'full';

  // Only process form view modes.
  if ($view_mode !== 'form' && $view_mode !== 'default') {
    return;
  }

  // Check if this is a vendor entity form.
  if ($entity && $entity->getEntityTypeId() === 'myeventlane_vendor') {
    $variables['attributes']['class'][] = 'mel-entity-form';
    $variables['attributes']['class'][] = 'mel-entity-form--vendor';
  }
}

/**
 * Implements hook_theme_suggestions_HOOK_alter() for page.
 *
 * Forces event node add/edit forms to use front-end theme.
 */
function myeventlane_theme_theme_suggestions_page_alter(array &$suggestions, array $variables, $hook): void {
  $route_match = \Drupal::routeMatch();
  $route_name = $route_match->getRouteName();

  // Force front-end theme for event node add/edit forms.
  if (in_array($route_name, ['node.add', 'entity.node.edit_form'])) {
    $node_type = $route_match->getParameter('node_type');
    $node = $route_match->getParameter('node');

    // Check if this is an event node.
    if (($node_type && $node_type->id() === 'event') ||
        ($node instanceof NodeInterface && $node->bundle() === 'event')) {
      // Remove admin theme suggestions.
      $suggestions = array_filter($suggestions, function ($suggestion) {
        return strpos($suggestion, 'admin') === FALSE;
      });
    }
  }
}

/**
 * Implements hook_preprocess_form().
 *
 * Adds template suggestions and variables for event node forms.
 */
function myeventlane_theme_preprocess_form(array &$variables): void {
  $form = &$variables['element'];
  $form_id = $form['#form_id'] ?? '';

  // For event node forms, add template suggestions and pass node to template.
  if (in_array($form_id, ['node_event_form', 'node_event_edit_form'])) {
    // Get the node entity if available.
    $node = NULL;
    if (isset($form['#entity']) && $form['#entity'] instanceof NodeInterface) {
      $node = $form['#entity'];
    }
    elseif (isset($form['#node']) && $form['#node'] instanceof NodeInterface) {
      $node = $form['#node'];
    }

    // Add template suggestions - Drupal will look for these templates.
    // Template naming: form--node--event--form.html.twig.
    if (!isset($variables['theme_hook_suggestions'])) {
      $variables['theme_hook_suggestions'] = [];
    }
    // Add suggestions in priority order (most specific first).
    array_unshift($variables['theme_hook_suggestions'], 'form__node__event__form');
    array_unshift($variables['theme_hook_suggestions'], 'form__node_event_form');

    // Pass node to template (available as 'node' variable).
    $variables['node'] = $node;

    // Also make form available as 'form' for consistency with other templates.
    $variables['form'] = $form;

    // Add debug flag.
    $variables['debug'] = TRUE;

    // Debug: Check if sections exist in form at template preprocessing time.
    $has_location = isset($form['location']) ? 'YES' : 'NO';
    $has_booking = isset($form['booking_config']) ? 'YES' : 'NO';
    $has_visibility = isset($form['visibility']) ? 'YES' : 'NO';
    $form_keys = array_keys($form);
    $filtered_keys = array_filter($form_keys, function ($key) {
      return !str_starts_with($key, '#');
    });

    \Drupal::logger('myeventlane_theme')->notice('Event form template suggestion added. Form ID: @form_id, Node: @node. Sections: location=@loc, booking=@book, visibility=@vis. Keys: @keys', [
      '@form_id' => $form_id,
      '@node' => $node ? $node->id() : 'new',
      '@loc' => $has_location,
      '@book' => $has_booking,
      '@vis' => $has_visibility,
      // First 20 keys.
      '@keys' => implode(', ', array_slice($filtered_keys, 0, 20)),
    ]);
  }

  // Vendor profile settings form.
  if ($form_id === 'vendor_profile_settings') {
    // Add template suggestions for vendor profile settings form.
    if (!isset($variables['theme_hook_suggestions'])) {
      $variables['theme_hook_suggestions'] = [];
    }
    array_unshift($variables['theme_hook_suggestions'], 'form__vendor_profile_settings');
    array_unshift($variables['theme_hook_suggestions'], 'form__vendor-profile-settings');
  }
}

/**
 * Implements hook_form_alter().
 *
 * Adds classes and ensures proper styling for public-facing forms.
 */
function myeventlane_theme_form_alter(array &$form, FormStateInterface $form_state, string $form_id): void {
  // Only apply to front-end theme, not admin theme.
  $theme = \Drupal::theme()->getActiveTheme()->getName();
  if ($theme !== 'myeventlane_theme') {
    return;
  }
  // Event node forms.
  if (in_array($form_id, ['node_event_form', 'node_event_edit_form'])) {
    $form['#attributes']['class'][] = 'mel-form';
    $form['#attributes']['class'][] = 'mel-form--event';

    // Ensure Drupal's form behaviors are attached for #states API.
    $form['#attached']['library'][] = 'core/drupal.form';
    $form['#attached']['library'][] = 'core/drupal.states';

    // Attach Conditional Fields library if module is enabled.
    // This ensures conditional fields work for both admin and vendor forms.
    if (\Drupal::moduleHandler()->moduleExists('conditional_fields')) {
      $form['#attached']['library'][] = 'conditional_fields/conditional_fields';
    }

    // Attach custom event form enhancements.
    $form['#attached']['library'][] = 'myeventlane_theme/event-form';

    // Disable Honeypot flood control for event forms (vendors need to save drafts).
    if (isset($form['#attributes']['data-honeypot-time'])) {
      unset($form['#attributes']['data-honeypot-time']);
    }

    // Add form token to prevent duplicate submissions without flood control.
    if (!isset($form['form_token'])) {
      $form['form_token'] = [
        '#type' => 'token',
        '#default_value' => \Drupal::csrfToken()->get('node_event_form'),
      ];
    }

    // Wrap the entire form in our styled container.
    // IMPORTANT: Only wrap the form, don't modify field structure to preserve #states API.
    $is_edit = ($form_id === 'node_event_edit_form');
    $title = $is_edit ? t('Edit Event') : t('Create New Event');
    $intro = $is_edit
      ? t('Update your event details below. Changes will be saved when you submit the form.')
      : t('Share your event with the MyEventLane community. Fill out each section below to get started.');

    // Get node if editing.
    $node = NULL;
    if (isset($form['#entity']) && $form['#entity']) {
      $node = $form['#entity'];
    }
    elseif ($form_state->getFormObject() && method_exists($form_state->getFormObject(), 'getEntity')) {
      $node = $form_state->getFormObject()->getEntity();
    }

    $breadcrumb = '';
    if ($is_edit && $node && !$node->isNew()) {
      $url = $node->toUrl()->toString();
      $breadcrumb = '<nav class="mel-breadcrumb" aria-label="Breadcrumb"><a href="' . $url . '">' . $node->label() . '</a><span class="mel-breadcrumb-separator">/</span><span>Edit</span></nav>';
    }

    // Don't add prefix/suffix here - let the page template handle layout.
    // The node--event--form.html.twig template will handle the form structure.
    // Add wrapper class to form itself.
    $form['#attributes']['class'][] = 'mel-event-form-wrapper';
  }

  // User login form.
  if ($form_id === 'user_login_form') {
    $form['#attributes']['class'][] = 'mel-form';
    $form['#attributes']['class'][] = 'mel-form--login';
  }

  // User register form.
  if ($form_id === 'user_register_form') {
    $form['#attributes']['class'][] = 'mel-form';
    $form['#attributes']['class'][] = 'mel-form--register';
  }

  // User password reset form.
  if ($form_id === 'user_pass') {
    $form['#attributes']['class'][] = 'mel-form';
    $form['#attributes']['class'][] = 'mel-form--password';
  }

  // User edit form.
  if ($form_id === 'user_form') {
    $form['#attributes']['class'][] = 'mel-form';
    $form['#attributes']['class'][] = 'mel-form--user-edit';
  }

  // Vendor entity forms.
  if (strpos($form_id, 'myeventlane_vendor') === 0) {
    $form['#attributes']['class'][] = 'mel-form';
    $form['#attributes']['class'][] = 'mel-form--vendor';
  }

  // Vendor profile settings form.
  if ($form_id === 'vendor_profile_settings') {
    $form['#attributes']['class'][] = 'mel-form';
    $form['#attributes']['class'][] = 'mel-form--vendor-profile-settings';
  }

  // Commerce checkout form - ensure Commerce Stripe Payment Element libraries are attached.
  // Commerce Stripe should attach its library automatically, but we ensure it's there.
  // as a safeguard in case the payment form structure changes.
  if (\Drupal::moduleHandler()->moduleExists('commerce_stripe')) {
    // Ensure #attached array exists before accessing it.
    if (!isset($form['#attached'])) {
      $form['#attached'] = [];
    }
    if (!isset($form['#attached']['library'])) {
      $form['#attached']['library'] = [];
    }

    // Stripe Payment Element is rendered in the stripe_review pane (on review step).
    // not in payment_information pane. Check both locations for compatibility.
    $has_payment_element = FALSE;
    $has_card_element = FALSE;

    // Check stripe_review pane for Payment Element (new preferred method).
    if (isset($form['stripe_review']['stripe_payment_element'])) {
      $has_payment_element = TRUE;
    }
    // Also check payment_information for legacy Card Element support.
    elseif (isset($form['payment_information'])) {
      // Check if Stripe Payment Element is being used in payment_information (legacy).
      if (isset($form['payment_information']['stripe_payment_element'])) {
        $has_payment_element = TRUE;
      }
      // Check if old Card Element is being used (legacy method).
      // The stripe-form class can be on payment_information or nested in payment_details.
      elseif (isset($form['payment_information']['add_payment_method']['payment_details'])) {
        $payment_details = &$form['payment_information']['add_payment_method']['payment_details'];
        // Check if stripe-form class exists on payment_details or any nested element.
        $has_stripe_form_class = FALSE;
        if (isset($payment_details['#attributes']['class']) &&
            in_array('stripe-form', $payment_details['#attributes']['class'])) {
          $has_stripe_form_class = TRUE;
        }
        // Also check for Card Element mount point IDs (card-number-element, etc.)
        $has_card_element_ids = isset($payment_details['card_number']) ||
                                isset($payment_details['expiration']) ||
                                isset($payment_details['security_code']);

        if ($has_stripe_form_class || $has_card_element_ids) {
          $has_card_element = TRUE;
        }
      }
      // Fallback: check payment_information directly for stripe-form class.
      elseif (isset($form['payment_information']['#attributes']['class']) &&
              in_array('stripe-form', $form['payment_information']['#attributes']['class'])) {
        $has_card_element = TRUE;
      }
    }

    // Attach appropriate library based on which Stripe integration is used.
    if ($has_payment_element) {
      // Payment Element uses commerce_stripe/payment_element library.
      // This library depends on commerce_stripe/stripe, which will be auto-attached.
      if (!in_array('commerce_stripe/payment_element', $form['#attached']['library'])) {
        $form['#attached']['library'][] = 'commerce_stripe/payment_element';
      }
    }
    elseif ($has_card_element) {
      // Card Element uses commerce_stripe/form library.
      // This library depends on commerce_stripe/stripe, which will be auto-attached.
      if (!in_array('commerce_stripe/form', $form['#attached']['library'])) {
        $form['#attached']['library'][] = 'commerce_stripe/form';
      }
      // Explicitly ensure stripe library is attached (it should be via dependency, but be explicit).
      if (!in_array('commerce_stripe/stripe', $form['#attached']['library'])) {
        $form['#attached']['library'][] = 'commerce_stripe/stripe';
      }
    }

    // Fallback: If we're on checkout and payment_information exists but no library detected.
    // check the order's payment gateway to determine which library to attach.
    if (!$has_payment_element && !$has_card_element &&
        isset($form['payment_information']) &&
        (strpos($form_id, 'commerce_checkout') === 0 || $form_id === 'commerce_checkout_flow')) {
      try {
        // Try to get the order from the form.
        $order = NULL;
        if (isset($form['#order']) && $form['#order'] instanceof OrderInterface) {
          $order = $form['#order'];
        }
        elseif (isset($form_state) && method_exists($form_state, 'getFormObject')) {
          $form_object = $form_state->getFormObject();
          if (method_exists($form_object, 'getOrder')) {
            $order = $form_object->getOrder();
          }
        }

        if ($order && !$order->get('payment_gateway')->isEmpty()) {
          $gateway = $order->get('payment_gateway')->entity;
          if ($gateway && $gateway->getPluginId() === 'stripe_payment_element') {
            // Payment Element gateway - attach payment_element library.
            if (!in_array('commerce_stripe/payment_element', $form['#attached']['library'])) {
              $form['#attached']['library'][] = 'commerce_stripe/payment_element';
            }
          }
          elseif ($gateway && $gateway->getPluginId() === 'stripe') {
            // Legacy Card Element gateway - attach form library.
            if (!in_array('commerce_stripe/form', $form['#attached']['library'])) {
              $form['#attached']['library'][] = 'commerce_stripe/form';
            }
          }
        }
      }
      catch (\Exception $e) {
        // Silently fail - library attachment is not critical if detection fails.
      }
    }
  }
}

/**
 * Implements hook_preprocess_block().
 *
 * Adds category terms to the Home Hero block.
 */
function myeventlane_theme_preprocess_block(array &$variables): void {
  $plugin_id = $variables['plugin_id'] ?? '';
  $elements = $variables['elements'] ?? [];

  // Handle home-hero block content.
  // Check by plugin ID (block_content:home_hero) or by block content bundle.
  $is_home_hero = FALSE;
  if (strpos($plugin_id, 'block_content:') === 0) {
    // Extract bundle from plugin ID (e.g., "block_content:home_hero" -> "home_hero").
    $bundle = str_replace('block_content:', '', $plugin_id);
    if ($bundle === 'home_hero' || $bundle === 'home-hero') {
      $is_home_hero = TRUE;
    }
  }

  // Also check by block content entity if available.
  if (!$is_home_hero && isset($elements['#block_content'])) {
    $block_content = $elements['#block_content'];
    if ($block_content instanceof BlockContent) {
      $bundle = $block_content->bundle();
      if ($bundle === 'home_hero' || $bundle === 'home-hero') {
        $is_home_hero = TRUE;
      }
    }
  }

  if ($is_home_hero) {
    // Load category terms from the vocabulary used for the homepage hero.
    // Prefer 'event_type' (per spec), fall back to 'categories' if needed.
    try {
      $term_storage = \Drupal::entityTypeManager()->getStorage('taxonomy_term');
      $terms = [];

      foreach (['event_type', 'categories'] as $vid) {
        try {
          $terms = $term_storage->loadTree($vid, 0, NULL, TRUE);
          if (!empty($terms)) {
            break;
          }
        }
        catch (\Exception $e) {
          // Try next vocabulary.
        }
      }

      $categories = array_map(static function ($term) {
        // Normalize to a safe CSS class key.
        $key = strtolower($term->getName());
        $key = str_replace([' ', '&'], ['-', 'and'], $key);
        $key = preg_replace('/[^a-z0-9-]/', '', $key);

        return (object) [
          'tid' => $term->id(),
          'name' => $term->getName(),
          'url' => '/events/category/' . $term->id(),
          'class' => $key,
        ];
      }, $terms);

      $variables['categories'] = $categories;
    }
    catch (\Exception $e) {
      $variables['categories'] = [];
    }
  }
}

/**
 * Implements hook_theme_suggestions_form_alter().
 *
 * Ensures event form template is suggested for vendor console event creation route.
 * This is a safeguard to ensure form--node--event--form.html.twig is used
 * even when the form is nested inside the vendor console page template.
 */
function myeventlane_theme_theme_suggestions_form_alter(array &$suggestions, array $variables, $hook): void {
  $element = $variables['element'] ?? [];
  $form_id = $element['#form_id'] ?? '';
  $route_name = \Drupal::routeMatch()->getRouteName();

  // Force event form template suggestion for vendor console event creation route.
  if ($form_id === 'node_event_form' && $route_name === 'myeventlane_vendor.console.events_add') {
    // Prepend the most specific suggestion to ensure it's used first.
    array_unshift($suggestions, 'form__node__event__form');
  }
}

/**
 * Implements hook_preprocess_views_view_unformatted().
 *
 * Flags "event views" so we can apply the canonical grid wrapper only to
 * event listings (and not to every unformatted view across the site).
 */
function myeventlane_theme_preprocess_views_view_unformatted(array &$variables): void {
  $view = $variables['view'] ?? NULL;
  if (!$view instanceof ViewExecutable) {
    $variables['mel_is_event_view'] = FALSE;
    return;
  }

  $variables['mel_is_event_view'] = _myeventlane_theme_is_event_view($view);
}

/**
 * Implements hook_preprocess_views_view_fields().
 *
 * Populates the canonical event card field values for event Views.
 *
 * This keeps Twig dead-simple and ensures Home, Featured, Taxonomy, Search and
 * future event views render the same event card markup.
 */
function myeventlane_theme_preprocess_views_view_fields(array &$variables): void {
  $view = $variables['view'] ?? NULL;
  if (!$view instanceof ViewExecutable) {
    $variables['mel_is_event_view'] = FALSE;
    return;
  }

  $is_event_view = _myeventlane_theme_is_event_view($view);
  $variables['mel_is_event_view'] = $is_event_view;
  if (!$is_event_view) {
    return;
  }

  $row = $variables['row'] ?? NULL;
  if (!$row instanceof ResultRow || empty($row->_entity) || !$row->_entity instanceof NodeInterface) {
    return;
  }

  /** @var \Drupal\node\NodeInterface $node */
  $node = $row->_entity;
  if ($node->bundle() !== 'event') {
    return;
  }

  // Title.
  _myeventlane_theme_set_views_field_content($variables, 'title', $node->label());

  // URL.
  _myeventlane_theme_set_views_field_content($variables, 'view_node', $node->toUrl()->toString());

  // Image URL (optional).
  $image_url = '';
  if ($node->hasField('field_event_image') && !$node->get('field_event_image')->isEmpty()) {
    $file = $node->get('field_event_image')->entity;
    if ($file) {
      try {
        $image_url = \Drupal::service('file_url_generator')->generateString($file->getFileUri());
      }
      catch (\Throwable $e) {
        $image_url = '';
      }
    }
  }
  _myeventlane_theme_set_views_field_content($variables, 'field_image', $image_url);

  // Dates.
  $start_value = ($node->hasField('field_event_start') && !$node->get('field_event_start')->isEmpty())
    ? (string) $node->get('field_event_start')->value
    : '';
  $start_ts = $start_value ? (int) strtotime($start_value) : 0;

  if ($start_ts) {
    /** @var \Drupal\Core\Datetime\DateFormatterInterface $date_formatter */
    $date_formatter = \Drupal::service('date.formatter');
    _myeventlane_theme_set_views_field_content($variables, 'field_date_day', $date_formatter->format($start_ts, 'custom', 'd'));
    _myeventlane_theme_set_views_field_content($variables, 'field_date_month', $date_formatter->format($start_ts, 'custom', 'M'));
    _myeventlane_theme_set_views_field_content($variables, 'field_date', $date_formatter->format($start_ts, 'custom', 'M j, Y'));
  }
  else {
    _myeventlane_theme_set_views_field_content($variables, 'field_date_day', '');
    _myeventlane_theme_set_views_field_content($variables, 'field_date_month', '');
    _myeventlane_theme_set_views_field_content($variables, 'field_date', '');
  }

  // Location (venue name preferred).
  $location = '';
  if ($node->hasField('field_venue_name') && !$node->get('field_venue_name')->isEmpty()) {
    $location = (string) $node->get('field_venue_name')->value;
  }
  elseif ($node->hasField('field_location') && !$node->get('field_location')->isEmpty()) {
    $address = $node->get('field_location')->first();
    if ($address) {
      $locality = (string) ($address->get('locality')->getString() ?? '');
      $line1 = (string) ($address->get('address_line1')->getString() ?? '');
      $location = $locality ?: $line1;
    }
  }
  _myeventlane_theme_set_views_field_content($variables, 'field_location', $location);

  // Category + slug.
  $category = '';
  $category_slug = '';
  if ($node->hasField('field_category') && !$node->get('field_category')->isEmpty()) {
    $term = $node->get('field_category')->entity;
    if ($term instanceof TermInterface) {
      $category = $term->label();
      $category_slug = _myeventlane_theme_slugify($category);
    }
  }
  _myeventlane_theme_set_views_field_content($variables, 'field_category', $category);
  _myeventlane_theme_set_views_field_content($variables, 'field_category_slug', $category_slug);

  // Ticket type + label.
  $ticket_type = 'rsvp';
  $ticket_label = 'RSVP';
  $event_type = ($node->hasField('field_event_type') && !$node->get('field_event_type')->isEmpty())
    ? (string) $node->get('field_event_type')->value
    : 'rsvp';

  if (in_array($event_type, ['paid', 'both', 'external'], TRUE)) {
    $ticket_type = 'tickets';
    $ticket_label = ($event_type === 'external') ? 'Get Tickets' : 'Tickets';
  }

  _myeventlane_theme_set_views_field_content($variables, 'field_ticket_type', $ticket_type);
  _myeventlane_theme_set_views_field_content($variables, 'field_ticket_label', $ticket_label);

  // Accessibility icons (array of emoji).
  $icons = [];
  if ($node->hasField('field_accessibility') && !$node->get('field_accessibility')->isEmpty()) {
    $icon_map = _myeventlane_theme_accessibility_icon_map();
    foreach ($node->get('field_accessibility')->referencedEntities() as $term) {
      if (!$term instanceof TermInterface) {
        continue;
      }
      $key = _myeventlane_theme_slugify($term->label());
      $key = str_replace('-', '_', $key);
      $icons[] = $icon_map[$key] ?? '♿';
    }
  }
  _myeventlane_theme_set_views_field_content($variables, 'field_accessibility_icons', $icons);
}

/**
 * Determines if a Views display is an "event view".
 */
function _myeventlane_theme_is_event_view(ViewExecutable $view): bool {
  if (($view->storage->get('base_table') ?? '') !== 'node_field_data') {
    return FALSE;
  }

  $filters = (array) $view->display_handler->getOption('filters');
  if (empty($filters['type']['value']) || !is_array($filters['type']['value'])) {
    // Some event listings (notably taxonomy term pages / argument-based views)
    // don't always expose the "Content type" filter in the display options.
    // Fall back to inspecting the executed results.
    if (!empty($view->result) && is_array($view->result)) {
      foreach ($view->result as $row) {
        if ($row instanceof ResultRow && !empty($row->_entity) && $row->_entity instanceof NodeInterface) {
          return $row->_entity->bundle() === 'event';
        }
      }
    }
    return FALSE;
  }

  if (isset($filters['type']['value']['event'])) {
    return TRUE;
  }

  // As an additional safety net, treat the view as an event listing when the results are event nodes.
  // This handles displays where the type filter is present but empty/misconfigured.
  if (!empty($view->result) && is_array($view->result)) {
    foreach ($view->result as $row) {
      if ($row instanceof ResultRow && !empty($row->_entity) && $row->_entity instanceof NodeInterface) {
        return $row->_entity->bundle() === 'event';
      }
    }
  }

  return FALSE;
}

/**
 * Sets a Views field's rendered content (object-safe).
 */
function _myeventlane_theme_set_views_field_content(array &$variables, string $field_id, mixed $content): void {
  if (empty($variables['fields'][$field_id])) {
    return;
  }

  if (is_object($variables['fields'][$field_id])) {
    $variables['fields'][$field_id]->content = $content;
  }
  elseif (is_array($variables['fields'][$field_id])) {
    $variables['fields'][$field_id]['content'] = $content;
  }
}

/**
 * Slugifies a label into a safe CSS class fragment.
 */
function _myeventlane_theme_slugify(string $value): string {
  $key = strtolower($value);
  $key = str_replace([' ', '&'], ['-', 'and'], $key);
  $key = preg_replace('/[^a-z0-9-]/', '', $key);
  return $key;
}

/**
 * Accessibility icon mapping (slug => emoji).
 */
function _myeventlane_theme_accessibility_icon_map(): array {
  return [
    'wheelchair_accessible' => '♿',
    'accessible_toilets' => '🚻',
    'sign_language_interpreter' => '👋',
    'hearing_loop' => '🔊',
    'quiet_space' => '🔇',
    'guide_dog_friendly' => '🐕',
    'accessible_parking' => '🅿️',
    'step_free_access' => '♿',
    'visual_impairment_support' => '👁️',
    'cognitive_accessibility' => '🧠',
    'dietary_requirements' => '🥗',
  ];
}

/**
 * Implements hook_preprocess_search_result().
 *
 * Renders Event node search results using the canonical event card.
 */
function myeventlane_theme_preprocess_search_result(array &$variables): void {
  $variables['mel_is_event_search_result'] = FALSE;
  $variables['mel_event_card'] = [];

  if (($variables['plugin_id'] ?? '') !== 'node_search') {
    return;
  }

  $result = $variables['result'] ?? [];
  $node = $result['node'] ?? NULL;
  if (!$node instanceof NodeInterface) {
    return;
  }

  if ($node->bundle() !== 'event') {
    return;
  }

  // Build the canonical event-card variables.
  $url = $node->toUrl()->toString();
  $title = $node->label();

  $image_url = '';
  if ($node->hasField('field_event_image') && !$node->get('field_event_image')->isEmpty()) {
    $file = $node->get('field_event_image')->entity;
    if ($file) {
      try {
        $image_url = \Drupal::service('file_url_generator')->generateString($file->getFileUri());
      }
      catch (\Throwable $e) {
        $image_url = '';
      }
    }
  }

  $start_value = ($node->hasField('field_event_start') && !$node->get('field_event_start')->isEmpty())
    ? (string) $node->get('field_event_start')->value
    : '';
  $start_ts = $start_value ? (int) strtotime($start_value) : 0;

  $date_day = '';
  $date_month = '';
  $date_full = '';
  if ($start_ts) {
    /** @var \Drupal\Core\Datetime\DateFormatterInterface $date_formatter */
    $date_formatter = \Drupal::service('date.formatter');
    $date_day = $date_formatter->format($start_ts, 'custom', 'd');
    $date_month = $date_formatter->format($start_ts, 'custom', 'M');
    $date_full = $date_formatter->format($start_ts, 'custom', 'M j, Y');
  }

  $location = '';
  if ($node->hasField('field_venue_name') && !$node->get('field_venue_name')->isEmpty()) {
    $location = (string) $node->get('field_venue_name')->value;
  }
  elseif ($node->hasField('field_location') && !$node->get('field_location')->isEmpty()) {
    $address = $node->get('field_location')->first();
    if ($address) {
      $locality = (string) ($address->get('locality')->getString() ?? '');
      $line1 = (string) ($address->get('address_line1')->getString() ?? '');
      $location = $locality ?: $line1;
    }
  }

  $category = '';
  $category_slug = '';
  if ($node->hasField('field_category') && !$node->get('field_category')->isEmpty()) {
    $term = $node->get('field_category')->entity;
    if ($term instanceof TermInterface) {
      $category = $term->label();
      $category_slug = _myeventlane_theme_slugify($category);
    }
  }

  $ticket_type = 'rsvp';
  $ticket_label = 'RSVP';
  $event_type = ($node->hasField('field_event_type') && !$node->get('field_event_type')->isEmpty())
    ? (string) $node->get('field_event_type')->value
    : 'rsvp';

  if (in_array($event_type, ['paid', 'both', 'external'], TRUE)) {
    $ticket_type = 'tickets';
    $ticket_label = ($event_type === 'external') ? 'Get Tickets' : 'Tickets';
  }

  $accessibility = [];
  if ($node->hasField('field_accessibility') && !$node->get('field_accessibility')->isEmpty()) {
    $icon_map = _myeventlane_theme_accessibility_icon_map();
    foreach ($node->get('field_accessibility')->referencedEntities() as $term) {
      if (!$term instanceof TermInterface) {
        continue;
      }
      $key = _myeventlane_theme_slugify($term->label());
      $key = str_replace('-', '_', $key);
      $accessibility[] = $icon_map[$key] ?? '♿';
    }
  }

  $variables['mel_is_event_search_result'] = TRUE;
  $variables['mel_event_card'] = [
    'title' => $title,
    'url' => $url,
    'image' => $image_url,
    'date_day' => $date_day,
    'date_month' => $date_month,
    'date_full' => $date_full,
    'location' => $location,
    'category' => $category,
    'category_slug' => $category_slug,
    'ticket_type' => $ticket_type,
    'ticket_label' => $ticket_label,
    'accessibility' => $accessibility,
  ];
}

/**
 * Helper function to compute registration badge text for event nodes.
 */
function _myeventlane_theme_event_registration_badge(NodeInterface $node): string {
  $state = '';
  if ($node->hasField('field_event_state_override') && !$node->get('field_event_state_override')->isEmpty()) {
    $state = (string) $node->get('field_event_state_override')->value;
  }
  elseif ($node->hasField('field_event_state') && !$node->get('field_event_state')->isEmpty()) {
    $state = (string) $node->get('field_event_state')->value;
  }

  if ($state === 'cancelled') {
    return (string) t('Cancelled');
  }

  $now = new \DateTimeImmutable('now', new \DateTimeZone(date_default_timezone_get()));

  $sales_start = NULL;
  if ($node->hasField('field_sales_start') && !$node->get('field_sales_start')->isEmpty()) {
    $sales_start = new \DateTimeImmutable((string) $node->get('field_sales_start')->value);
  }

  $sales_end = NULL;
  if ($node->hasField('field_sales_end') && !$node->get('field_sales_end')->isEmpty()) {
    $sales_end = new \DateTimeImmutable((string) $node->get('field_sales_end')->value);
  }

  if ($sales_start && $now < $sales_start) {
    return (string) t('Registration not open yet');
  }
  if ($sales_end && $now > $sales_end) {
    return (string) t('Registration closed');
  }

  return (string) t('Tickets available');
}

/**
 * Helper function to compute capacity text for event nodes.
 */
function _myeventlane_theme_event_capacity_text(NodeInterface $node): ?string {
  // Choose a single authoritative capacity field for display.
  // Recommend: field_event_capacity_total.
  if (!$node->hasField('field_event_capacity_total') || $node->get('field_event_capacity_total')->isEmpty()) {
    return NULL;
  }

  $total = (int) $node->get('field_event_capacity_total')->value;
  if ($total <= 0) {
    return NULL;
  }

  // Phase 1: show total only.
  // Phase 2: subtract registrations/orders to show remaining.
  return (string) t('@total total capacity', ['@total' => $total]);
}

/**
 * Helper function to generate calendar links for event nodes.
 *
 * Note: This function is kept for backward compatibility.
 * The node--event--full.html.twig template uses mel_ics_url and mel_google_cal_url
 * directly, which are computed in the main preprocess function above.
 */
function _myeventlane_theme_event_calendar_links(NodeInterface $node): array {
  $items = [];
  
  // ICS download URL.
  try {
    $ics_url = Url::fromRoute('myeventlane_rsvp.ics_download', ['node' => $node->id()]);
    $items[] = [
      '#type' => 'link',
      '#title' => t('Apple / Outlook (.ics)'),
      '#url' => $ics_url,
      '#attributes' => [
        'download' => $node->label() . '.ics',
        'rel' => 'nofollow',
      ],
    ];
  }
  catch (\Exception $e) {
    // Route not available, skip.
  }

  // Google Calendar URL.
  if ($node->hasField('field_event_start') && !$node->get('field_event_start')->isEmpty()) {
    $start_value = $node->get('field_event_start')->value;
    $end_value = $node->hasField('field_event_end') && !$node->get('field_event_end')->isEmpty()
      ? $node->get('field_event_end')->value
      : NULL;

    $start_iso = gmdate('Ymd\THis\Z', strtotime($start_value));
    $end_iso = $end_value ? gmdate('Ymd\THis\Z', strtotime($end_value)) : gmdate('Ymd\THis\Z', strtotime($start_value . ' +2 hours'));

    $title_encoded = rawurlencode($node->label());
    $venue = '';
    if ($node->hasField('field_venue_name') && !$node->get('field_venue_name')->isEmpty()) {
      $venue = $node->get('field_venue_name')->value;
    }
    $address = '';
    if ($node->hasField('field_location') && !$node->get('field_location')->isEmpty()) {
      $item = $node->get('field_location')->first();
      if ($item) {
        $v = $item->getValue();
        $parts = [];
        if (!empty($v['address_line1'])) {
          $parts[] = $v['address_line1'];
        }
        if (!empty($v['locality'])) {
          $parts[] = $v['locality'];
        }
        if (!empty($v['administrative_area'])) {
          $parts[] = $v['administrative_area'];
        }
        if (!empty($v['postal_code'])) {
          $parts[] = $v['postal_code'];
        }
        $address = implode(', ', array_filter($parts));
      }
    }
    $location_parts = array_filter([$venue, $address]);
    $location_encoded = rawurlencode(implode(', ', $location_parts));
    $details_encoded = rawurlencode(strip_tags($node->hasField('body') && !$node->get('body')->isEmpty() ? $node->get('body')->value : ''));
    $url_encoded = rawurlencode($node->toUrl('canonical', ['absolute' => TRUE])->toString());

    $google_cal_url = "https://calendar.google.com/calendar/render?action=TEMPLATE"
      . "&text={$title_encoded}"
      . "&dates={$start_iso}/{$end_iso}"
      . "&details={$details_encoded}"
      . "&location={$location_encoded}"
      . "&ctz=" . date_default_timezone_get();
    
    $items[] = [
      '#type' => 'link',
      '#title' => t('Google Calendar'),
      '#url' => Url::fromUri($google_cal_url),
      '#attributes' => ['rel' => 'nofollow noopener', 'target' => '_blank'],
    ];
  }

  if (empty($items)) {
    return [];
  }

  return [
    '#theme' => 'item_list',
    '#items' => $items,
    '#attributes' => ['class' => ['mel-links-inline__list']],
    '#cache' => [
      'tags' => $node->getCacheTags(),
      'contexts' => ['url.path', 'languages:language_interface'],
    ],
  ];
}

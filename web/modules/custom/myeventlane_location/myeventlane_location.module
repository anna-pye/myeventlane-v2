<?php

/**
 * @file
 * Hook implementations for myeventlane_location module.
 *
 * Provides address autocomplete with Google Maps and Apple Maps support,
 * and embedded map rendering on Event pages.
 */

declare(strict_types=1);

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\node\NodeInterface;

/**
 * Implements hook_theme().
 */
function myeventlane_location_theme(): array {
  return [
    'event_location_map' => [
      'variables' => [
        'event' => NULL,
        'latitude' => NULL,
        'longitude' => NULL,
        'address' => NULL,
        'venue_name' => NULL,
        'provider' => NULL,
      ],
      'template' => 'event-location-map',
    ],
    'event_location_info' => [
      'variables' => [
        'event' => NULL,
        'address' => NULL,
        'venue_name' => NULL,
      ],
      'template' => 'event-location-info',
    ],
  ];
}

/**
 * Implements hook_form_FORM_ID_alter() for node_event_form.
 */
function myeventlane_location_form_node_event_form_alter(array &$form, FormStateInterface $form_state, string $form_id): void {
  _myeventlane_location_alter_event_form($form, $form_state);
}

/**
 * Implements hook_form_FORM_ID_alter() for node_event_edit_form.
 */
function myeventlane_location_form_node_event_edit_form_alter(array &$form, FormStateInterface $form_state, string $form_id): void {
  _myeventlane_location_alter_event_form($form, $form_state);
}

/**
 * Implements hook_form_FORM_ID_alter() for vendor_event_create_form.
 */
function myeventlane_location_form_vendor_event_create_form_alter(array &$form, FormStateInterface $form_state, string $form_id): void {
  _myeventlane_location_alter_event_form($form, $form_state);
}

/**
 * Alters the event node form to add address autocomplete widget.
 *
 * @param array $form
 *   The form array.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state.
 */
function _myeventlane_location_alter_event_form(array &$form, FormStateInterface $form_state): void {
  // CRITICAL: Always attach drupalSettings for JavaScript, even if field_location doesn't exist yet.
  // This must happen before any early returns.
  // Get provider settings for JavaScript.
  /** @var \Drupal\myeventlane_location\Service\LocationProviderManager $provider_manager */
  $provider_manager = \Drupal::service('myeventlane_location.provider_manager');
  $settings = $provider_manager->getFrontendSettings();

  // For Apple Maps, we need to generate a token server-side.
  if ($settings['provider'] === 'apple_maps') {
    /** @var \Drupal\myeventlane_location\Service\MapKitTokenGenerator $token_generator */
    $token_generator = \Drupal::service('myeventlane_location.mapkit_token_generator');
    $token = $token_generator->generateToken();
    if (!empty($token)) {
      $settings['apple_maps_token'] = $token;
    }
  }

  // Attach drupalSettings - this is critical for the JavaScript to work.
  // Merge with existing settings if any (from widget or other modules).
  if (!isset($form['#attached']['drupalSettings'])) {
    $form['#attached']['drupalSettings'] = [];
  }
  if (!isset($form['#attached']['drupalSettings']['myeventlaneLocation'])) {
    $form['#attached']['drupalSettings']['myeventlaneLocation'] = [];
  }
  // Merge settings to preserve any existing values (like Apple Maps token from widget).
  $form['#attached']['drupalSettings']['myeventlaneLocation'] = array_merge(
    $form['#attached']['drupalSettings']['myeventlaneLocation'],
    $settings
  );

  // Only alter field_location if it exists.
  if (!isset($form['field_location'])) {
    // Still attach library even if field doesn't exist (might be added later).
    $form['#attached']['library'][] = 'myeventlane_location/address_autocomplete';
    return;
  }

  // NOTE: The AddressAutocompleteWidget already adds:
  // - A search field with class 'myeventlane-location-address-search'
  // - A map preview container with class 'myeventlane-location-map-preview'
  // - Hidden latitude/longitude fields
  // - The widget wrapper class 'myeventlane-location-address-widget'
  // So we don't need to add these again here.
  
  // However, we still need to:
  // 1. Ensure the widget has the wrapper class (widget should add it, but double-check)
  if (!isset($form['field_location']['#attributes'])) {
    $form['field_location']['#attributes'] = [];
  }
  if (!isset($form['field_location']['#attributes']['class'])) {
    $form['field_location']['#attributes']['class'] = [];
  }
  if (!in_array('myeventlane-location-address-widget', $form['field_location']['#attributes']['class'])) {
    $form['field_location']['#attributes']['class'][] = 'myeventlane-location-address-widget';
  }
  
  // 2. Update field_location title to be more descriptive (if widget hasn't already)
  if (isset($form['field_location']['#title']) && $form['field_location']['#title'] === 'Location') {
    $form['field_location']['#title'] = t('Address Details');
    if (!isset($form['field_location']['#description'])) {
      $form['field_location']['#description'] = t('Use the search field above to find and select an address. The address fields below will be automatically filled.');
    }
  }

  // Hide the coordinate fields from the form display if they're showing up.
  // We'll use hidden form elements instead that are populated by JavaScript.
  $node = $form_state->getFormObject()->getEntity();
  
  // Hide the actual coordinate fields if they exist in the form.
  if (isset($form['field_location_latitude'])) {
    $form['field_location_latitude']['#access'] = FALSE;
  }
  if (isset($form['field_location_longitude'])) {
    $form['field_location_longitude']['#access'] = FALSE;
  }
  
  // Add our own hidden fields for coordinates (these will be populated by JavaScript).
  // These are separate from the actual entity fields to avoid validation issues.
  if ($node->hasField('field_location_latitude')) {
    $form['myeventlane_location_latitude'] = [
      '#type' => 'hidden',
      '#attributes' => [
        'class' => ['myeventlane-location-latitude-field'],
      ],
      '#default_value' => !$node->get('field_location_latitude')->isEmpty() 
        ? (string) $node->get('field_location_latitude')->value 
        : '',
    ];
  }

  if ($node->hasField('field_location_longitude')) {
    $form['myeventlane_location_longitude'] = [
      '#type' => 'hidden',
      '#attributes' => [
        'class' => ['myeventlane-location-longitude-field'],
      ],
      '#default_value' => !$node->get('field_location_longitude')->isEmpty() 
        ? (string) $node->get('field_location_longitude')->value 
        : '',
    ];
  }

  // The wrapper already has the class for JavaScript targeting.

  // Attach our library for autocomplete functionality.
  $form['#attached']['library'][] = 'myeventlane_location/address_autocomplete';

  // Note: drupalSettings are already attached at the top of this function
  // to ensure they're always available, even if field_location doesn't exist.

  // Add submit handler to save coordinates.
  if (isset($form['actions']['submit'])) {
    $form['actions']['submit']['#submit'][] = '_myeventlane_location_save_coordinates';
  }
}



/**
 * Form submit handler to save latitude and longitude from address widget.
 */
function _myeventlane_location_save_coordinates(array &$form, FormStateInterface $form_state): void {
  $node = $form_state->getFormObject()->getEntity();
  if (!$node instanceof NodeInterface || $node->bundle() !== 'event') {
    return;
  }

  $lat = NULL;
  $lng = NULL;

  // Get coordinates from our hidden fields added by form_alter.
  // We use custom field names to avoid validation issues with the actual entity fields.
  $user_input = $form_state->getUserInput();
  
  // Check our custom hidden fields first (from form submission).
  if (isset($user_input['myeventlane_location_latitude']) && !empty($user_input['myeventlane_location_latitude']) && is_numeric($user_input['myeventlane_location_latitude'])) {
    $lat = (float) $user_input['myeventlane_location_latitude'];
  }
  elseif ($form_state->hasValue('myeventlane_location_latitude')) {
    $lat_value = $form_state->getValue('myeventlane_location_latitude');
    if (!empty($lat_value) && is_numeric($lat_value)) {
      $lat = (float) $lat_value;
    }
  }

  if (isset($user_input['myeventlane_location_longitude']) && !empty($user_input['myeventlane_location_longitude']) && is_numeric($user_input['myeventlane_location_longitude'])) {
    $lng = (float) $user_input['myeventlane_location_longitude'];
  }
  elseif ($form_state->hasValue('myeventlane_location_longitude')) {
    $lng_value = $form_state->getValue('myeventlane_location_longitude');
    if (!empty($lng_value) && is_numeric($lng_value)) {
      $lng = (float) $lng_value;
    }
  }
  
  // Also check the actual entity fields in case they were set directly.
  if ($lat === NULL && isset($user_input['field_location_latitude']) && !empty($user_input['field_location_latitude']) && is_numeric($user_input['field_location_latitude'])) {
    $lat = (float) $user_input['field_location_latitude'];
  }
  if ($lng === NULL && isset($user_input['field_location_longitude']) && !empty($user_input['field_location_longitude']) && is_numeric($user_input['field_location_longitude'])) {
    $lng = (float) $user_input['field_location_longitude'];
  }

  // Check for dedicated coordinate fields (field_location_latitude/longitude or field_event_lat/lng).
  if ($lat === NULL && $form_state->hasValue(['field_location_latitude', 0, 'value'])) {
    $lat_value = $form_state->getValue(['field_location_latitude', 0, 'value']);
    if (!empty($lat_value) && is_numeric($lat_value)) {
      $lat = (float) $lat_value;
    }
  }

  if ($lng === NULL && $form_state->hasValue(['field_location_longitude', 0, 'value'])) {
    $lng_value = $form_state->getValue(['field_location_longitude', 0, 'value']);
    if (!empty($lng_value) && is_numeric($lng_value)) {
      $lng = (float) $lng_value;
    }
  }

  // Check for legacy field_event_lat/lng fields.
  if ($lat === NULL && $form_state->hasValue(['field_event_lat', 0, 'value'])) {
    $lat_value = $form_state->getValue(['field_event_lat', 0, 'value']);
    if (!empty($lat_value) && is_numeric($lat_value)) {
      $lat = (float) $lat_value;
    }
  }

  if ($lng === NULL && $form_state->hasValue(['field_event_lng', 0, 'value'])) {
    $lng_value = $form_state->getValue(['field_event_lng', 0, 'value']);
    if (!empty($lng_value) && is_numeric($lng_value)) {
      $lng = (float) $lng_value;
    }
  }

  // Save coordinates to dedicated fields if they exist and we have values.
  if ($lat !== NULL && $node->hasField('field_location_latitude')) {
    $node->set('field_location_latitude', $lat);
    \Drupal::logger('myeventlane_location')->notice('Saved latitude: @lat', ['@lat' => $lat]);
  }
  elseif ($lat !== NULL && $node->hasField('field_event_lat')) {
    $node->set('field_event_lat', (string) $lat);
    \Drupal::logger('myeventlane_location')->notice('Saved latitude (legacy): @lat', ['@lat' => $lat]);
  }
  else {
    \Drupal::logger('myeventlane_location')->warning('Latitude not saved. Lat: @lat, Has field: @has', [
      '@lat' => $lat !== NULL ? $lat : 'NULL',
      '@has' => $node->hasField('field_location_latitude') ? 'YES' : 'NO',
    ]);
  }

  if ($lng !== NULL && $node->hasField('field_location_longitude')) {
    $node->set('field_location_longitude', $lng);
    \Drupal::logger('myeventlane_location')->notice('Saved longitude: @lng', ['@lng' => $lng]);
  }
  elseif ($lng !== NULL && $node->hasField('field_event_lng')) {
    $node->set('field_event_lng', (string) $lng);
    \Drupal::logger('myeventlane_location')->notice('Saved longitude (legacy): @lng', ['@lng' => $lng]);
  }
  else {
    \Drupal::logger('myeventlane_location')->warning('Longitude not saved. Lng: @lng, Has field: @has', [
      '@lng' => $lng !== NULL ? $lng : 'NULL',
      '@has' => $node->hasField('field_location_longitude') ? 'YES' : 'NO',
    ]);
  }
}

/**
 * Implements hook_page_attachments().
 */
function myeventlane_location_page_attachments(array &$attachments): void {
  // Only attach on Event node view pages.
  $route = \Drupal::routeMatch();
  if ($route->getRouteName() !== 'entity.node.canonical') {
    return;
  }

  $node = $route->getParameter('node');
  if (!$node instanceof NodeInterface || $node->bundle() !== 'event') {
    return;
  }

  // Check if event has location coordinates.
  $lat = NULL;
  $lng = NULL;

  // Try to get coordinates from dedicated fields first.
  if ($node->hasField('field_location_latitude') && !$node->get('field_location_latitude')->isEmpty()) {
    $lat = (float) $node->get('field_location_latitude')->value;
  }
  elseif ($node->hasField('field_event_lat') && !$node->get('field_event_lat')->isEmpty()) {
    $lat = (float) $node->get('field_event_lat')->value;
  }

  if ($node->hasField('field_location_longitude') && !$node->get('field_location_longitude')->isEmpty()) {
    $lng = (float) $node->get('field_location_longitude')->value;
  }
  elseif ($node->hasField('field_event_lng') && !$node->get('field_event_lng')->isEmpty()) {
    $lng = (float) $node->get('field_event_lng')->value;
  }

  // Only attach if we have coordinates.
  if ($lat !== NULL && $lng !== NULL) {
    // Attach map rendering library.
    $attachments['#attached']['library'][] = 'myeventlane_location/event_map';

    // Get provider settings.
    /** @var \Drupal\myeventlane_location\Service\LocationProviderManager $provider_manager */
    $provider_manager = \Drupal::service('myeventlane_location.provider_manager');
    $settings = $provider_manager->getFrontendSettings();

    // For Apple Maps, generate token.
    if ($settings['provider'] === 'apple_maps') {
      /** @var \Drupal\myeventlane_location\Service\MapKitTokenGenerator $token_generator */
      $token_generator = \Drupal::service('myeventlane_location.mapkit_token_generator');
      $token = $token_generator->generateToken();
      if (!empty($token)) {
        $settings['apple_maps_token'] = $token;
      }
    }

    $attachments['#attached']['drupalSettings']['myeventlaneLocation'] = $settings;
    $attachments['#attached']['drupalSettings']['myeventlaneLocationEvent'] = [
      'latitude' => $lat,
      'longitude' => $lng,
      'title' => $node->getTitle(),
    ];
  }
}

/**
 * Implements hook_ENTITY_TYPE_view() for node entities.
 *
 * Adds map rendering to Event node views.
 */
function myeventlane_location_node_view(array &$build, EntityInterface $entity, $view_mode): void {
  // Only process event nodes in full/default view modes.
  if (!$entity instanceof NodeInterface || $entity->bundle() !== 'event') {
    return;
  }

  if (!in_array($view_mode, ['full', 'default'], TRUE)) {
    return;
  }

  // Get coordinates.
  $lat = NULL;
  $lng = NULL;

  if ($entity->hasField('field_location_latitude') && !$entity->get('field_location_latitude')->isEmpty()) {
    $lat = (float) $entity->get('field_location_latitude')->value;
  }
  elseif ($entity->hasField('field_event_lat') && !$entity->get('field_event_lat')->isEmpty()) {
    $lat = (float) $entity->get('field_event_lat')->value;
  }

  if ($entity->hasField('field_location_longitude') && !$entity->get('field_location_longitude')->isEmpty()) {
    $lng = (float) $entity->get('field_location_longitude')->value;
  }
  elseif ($entity->hasField('field_event_lng') && !$entity->get('field_event_lng')->isEmpty()) {
    $lng = (float) $entity->get('field_event_lng')->value;
  }

  // Get address string from either field_location (new) or field_event_address (legacy).
  $address = '';
  $venue_name = '';

  $address_field = NULL;
  if ($entity->hasField('field_location') && !$entity->get('field_location')->isEmpty()) {
    $address_field = $entity->get('field_location');
  }
  elseif ($entity->hasField('field_event_address') && !$entity->get('field_event_address')->isEmpty()) {
    $address_field = $entity->get('field_event_address');
  }

  if ($address_field && !$address_field->isEmpty()) {
    $location_item = $address_field->first();
    if ($location_item) {
      $location = $location_item->getValue();
      if (is_array($location)) {
        $parts = [];
        if (!empty($location['address_line1'])) {
          $parts[] = $location['address_line1'];
        }
        if (!empty($location['locality'])) {
          $parts[] = $location['locality'];
        }
        if (!empty($location['administrative_area'])) {
          $parts[] = $location['administrative_area'];
        }
        if (!empty($location['postal_code'])) {
          $parts[] = $location['postal_code'];
        }
        $address = implode(', ', $parts);
      }
    }
  }

  // Get venue name from either field_venue_name (new) or field_event_venue (legacy).
  if ($entity->hasField('field_venue_name') && !$entity->get('field_venue_name')->isEmpty()) {
    $venue_name = $entity->get('field_venue_name')->value;
  }
  elseif ($entity->hasField('field_event_venue') && !$entity->get('field_event_venue')->isEmpty()) {
    $venue_name = $entity->get('field_event_venue')->value;
  }

  // Only add map if coordinates exist.
  if ($lat !== NULL && $lng !== NULL) {

    /** @var \Drupal\myeventlane_location\Service\LocationProviderManager $provider_manager */
    $provider_manager = \Drupal::service('myeventlane_location.provider_manager');
    $provider = $provider_manager->getDefaultProvider();

    // Add map to build array.
    $build['event_location_map'] = [
      '#theme' => 'event_location_map',
      '#event' => $entity,
      '#latitude' => $lat,
      '#longitude' => $lng,
      '#address' => $address,
      '#venue_name' => $venue_name,
      '#provider' => $provider,
      '#weight' => 100,
      '#cache' => [
        'tags' => $entity->getCacheTags(),
        'contexts' => ['url.path'],
      ],
    ];
  }
  // Even if no coordinates, add venue name and address info if available.
  elseif (!empty($venue_name) || !empty($address)) {
    $build['event_location_info'] = [
      '#theme' => 'event_location_info',
      '#event' => $entity,
      '#address' => $address,
      '#venue_name' => $venue_name,
      '#weight' => 100,
      '#cache' => [
        'tags' => $entity->getCacheTags(),
        'contexts' => ['url.path'],
      ],
    ];
  }
}


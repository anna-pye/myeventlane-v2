<?php

declare(strict_types=1);

namespace Drupal\myeventlane_dashboard\Controller;

use Drupal\Component\Datetime\TimeInterface;
use Drupal\Core\Controller\ControllerBase;
use Drupal\Core\Url;
use Drupal\myeventlane_boost\BoostManager;
use Drupal\myeventlane_dashboard\Service\DashboardAccess;
use Drupal\myeventlane_dashboard\Service\DashboardEventLoader;
use Symfony\Component\DependencyInjection\ContainerInterface;
use Symfony\Component\DependencyInjection\Exception\ServiceNotFoundException;
use Symfony\Component\HttpFoundation\RedirectResponse;

/**
 * Controller for the vendor dashboard.
 */
final class VendorDashboardController extends ControllerBase {

  /**
   * Constructs a VendorDashboardController object.
   */
  public function __construct(
    private readonly DashboardAccess $dashboardAccess,
    private readonly DashboardEventLoader $eventLoader,
    private readonly TimeInterface $time,
    private readonly ?BoostManager $boostManager = NULL,
  ) {}

  /**
   * {@inheritdoc}
   */
  public static function create(ContainerInterface $container): static {
    try {
      $boostManager = $container->get('myeventlane_boost.manager');
    }
    catch (\Exception) {
      $boostManager = NULL;
    }

    return new static(
      $container->get('myeventlane_dashboard.access'),
      $container->get('myeventlane_dashboard.event_loader'),
      $container->get('datetime.time'),
      $boostManager,
    );
  }

  /**
   * Redirects from old /dashboard path to /vendor/dashboard.
   */
  public function legacyRedirect(): RedirectResponse {
    return new RedirectResponse(
      Url::fromRoute('myeventlane_dashboard.vendor')->toString(),
      301
    );
  }

  /**
   * Gets attendee and revenue stats for an event.
   *
   * @param int $eventId
   *   The event node ID.
   *
   * @return array
   *   Array with 'attendee_count', 'revenue', and 'mode'.
   */
  private function getEventStats(int $eventId): array {
    // Get attendee count using entity query API.
    $attendeeCount = $this->entityTypeManager()
      ->getStorage('event_attendee')
      ->getQuery()
      ->accessCheck(FALSE)
      ->condition('event', $eventId)
      ->condition('status', 'confirmed')
      ->count()
      ->execute();

    // Get revenue from Commerce orders.
    // Find all order items linked to this event.
    $orderItemStorage = $this->entityTypeManager()->getStorage('commerce_order_item');
    $orderItems = $orderItemStorage->loadByProperties([
      'field_target_event' => $eventId,
    ]);

    $revenue = 0;
    foreach ($orderItems as $item) {
      $totalPrice = $item->getTotalPrice();
      if ($totalPrice) {
        $revenue += (float) $totalPrice->getNumber();
      }
    }

    // Get event mode.
    $eventNode = $this->entityTypeManager()->getStorage('node')->load($eventId);
    $mode = 'unknown';
    if ($eventNode) {
      try {
        $modeManager = \Drupal::service('myeventlane_event.mode_manager');
        $mode = $modeManager->getEffectiveMode($eventNode);
      }
      catch (ServiceNotFoundException) {
        // Service not available, use default mode.
      }
    }

    return [
      'attendee_count' => (int) $attendeeCount,
      'revenue' => $revenue,
      'mode' => $mode,
    ];
  }

  /**
   * Renders the vendor dashboard page.
   *
   * @return array
   *   A render array for the vendor dashboard.
   */
  public function dashboard(): array {
    $currentUser = $this->currentUser();
    // Load events for the current user (admin=FALSE loads only user's events).
    $events = $this->eventLoader->loadEvents(FALSE, 50);

    // Build event summary data.
    $upcomingEvents = [];
    $pastEvents = [];
    $now = $this->time->getRequestTime();

    foreach ($events as $event) {
      $startTime = NULL;

      // Get start time from datetime field.
      if ($event->hasField('field_event_start') && !$event->get('field_event_start')->isEmpty()) {
        $dateItem = $event->get('field_event_start');
        if ($dateItem->date) {
          $startTime = $dateItem->date->getTimestamp();
        }
        // Fallback to value parsing if date object not available.
        elseif (!empty($dateItem->value)) {
          try {
            $startTime = strtotime($dateItem->value);
          }
          catch (\Exception) {
            // Ignore date parsing errors.
          }
        }
      }

      // Get attendee counts and revenue for this event.
      $stats = $this->getEventStats((int) $event->id());

      // Get Boost status.
      $boostStatus = $this->getBoostStatus($event);

      $eventData = [
        'id' => $event->id(),
        'title' => $event->label(),
        'url' => $event->toUrl()->toString(),
        'edit_url' => $event->toUrl('edit-form')->toString(),
        'start_date' => $startTime ? date('M j, Y', $startTime) : '',
        'start_time' => $startTime ? date('g:ia', $startTime) : '',
        'attendee_count' => $stats['attendee_count'],
        'revenue' => $stats['revenue'],
        'event_mode' => $stats['mode'],
        'boost_status' => $boostStatus,
      ];

      // Categorize events: upcoming if start time is in the future, otherwise past.
      // Events without dates go to past events.
      if ($startTime && $startTime > $now) {
        $upcomingEvents[] = $eventData;
      }
      else {
        $pastEvents[] = $eventData;
      }
    }

    // Quick action links.
    $quickLinks = [
      [
        'title' => $this->t('Create Event'),
        'url' => Url::fromRoute('node.add', ['node_type' => 'event'])->toString(),
        'icon' => 'add',
      ],
    ];

    // Get Stripe connection status.
    $stripeStatus = $this->getStripeStatus();
    
    // Add Stripe Connect links to quick actions.
    if ($stripeStatus) {
      if (!$stripeStatus['connected'] && $stripeStatus['connect_url']) {
        $quickLinks[] = [
          'title' => $this->t('Connect Stripe'),
          'url' => $stripeStatus['connect_url'],
          'icon' => 'payment',
        ];
      }
      if ($stripeStatus['connected'] && $stripeStatus['manage_url']) {
        $quickLinks[] = [
          'title' => $this->t('Manage Stripe'),
          'url' => $stripeStatus['manage_url'],
          'icon' => 'settings',
        ];
      }
    }

    return [
      '#theme' => 'myeventlane_vendor_dashboard',
      '#upcoming_events' => $upcomingEvents,
      '#past_events' => $pastEvents,
      '#quick_links' => $quickLinks,
      '#stripe_status' => $stripeStatus,
      '#welcome_message' => $this->t('Welcome back, @name. Here is an overview of your events.', [
        '@name' => $currentUser->getDisplayName(),
      ]),
      '#attached' => [
        'library' => ['myeventlane_dashboard/dashboard'],
      ],
      '#cache' => [
        'contexts' => ['user'],
        'tags' => ['node_list', 'user:' . $currentUser->id()],
        'max-age' => 300,
      ],
    ];
  }

  /**
   * Gets Stripe connection status for the current user's store.
   *
   * @return array
   *   Array with 'connected', 'status', 'account_id', 'connect_url', 'manage_url'.
   */
  private function getStripeStatus(): array {
    $currentUser = $this->currentUser();
    $userId = (int) $currentUser->id();

    if ($userId === 0) {
      return [
        'connected' => FALSE,
        'status' => 'unconnected',
        'account_id' => NULL,
        'connect_url' => NULL,
        'manage_url' => NULL,
      ];
    }

    // Find store for this user.
    $storeStorage = $this->entityTypeManager()->getStorage('commerce_store');
    $storeIds = $storeStorage->getQuery()
      ->accessCheck(FALSE)
      ->condition('uid', $userId)
      ->range(0, 1)
      ->execute();

    if (empty($storeIds)) {
      return [
        'connected' => FALSE,
        'status' => 'unconnected',
        'account_id' => NULL,
        'connect_url' => Url::fromRoute('myeventlane_vendor.stripe_connect')->toString(),
        'manage_url' => NULL,
      ];
    }

    $store = $storeStorage->load(reset($storeIds));
    if (!$store) {
      return [
        'connected' => FALSE,
        'status' => 'unconnected',
        'account_id' => NULL,
        'connect_url' => Url::fromRoute('myeventlane_vendor.stripe_connect')->toString(),
        'manage_url' => NULL,
      ];
    }

    // Check for Stripe account ID.
    $accountId = NULL;
    $status = 'unconnected';
    $connected = FALSE;

    if ($store->hasField('field_stripe_account_id') && !$store->get('field_stripe_account_id')->isEmpty()) {
      $accountId = $store->get('field_stripe_account_id')->value;
    }

    if ($store->hasField('field_stripe_status') && !$store->get('field_stripe_status')->isEmpty()) {
      $status = $store->get('field_stripe_status')->value;
    }
    elseif ($store->hasField('field_stripe_connected') && !$store->get('field_stripe_connected')->isEmpty()) {
      $connected = (bool) $store->get('field_stripe_connected')->value;
      $status = $connected ? 'complete' : 'pending';
    }
    elseif (!empty($accountId)) {
      $status = 'pending';
    }

    if ($status === 'complete') {
      $connected = TRUE;
    }

    // Build status labels and messages.
    $statusLabel = $this->t('Not Connected');
    $statusMessage = $this->t('Connect your Stripe account to start accepting payments.');

    if ($connected) {
      $statusLabel = $this->t('Connected');
      $statusMessage = $this->t('Your Stripe account is active and ready to accept payments.');
    }
    elseif ($status === 'pending') {
      $statusLabel = $this->t('Pending');
      $statusMessage = $this->t('Your Stripe account is pending verification. Complete onboarding to start accepting payments.');
    }

    return [
      'connected' => $connected,
      'status' => $status,
      'status_label' => $statusLabel,
      'status_message' => $statusMessage,
      'account_id' => $accountId,
      'connect_url' => Url::fromRoute('myeventlane_vendor.stripe_connect')->toString(),
      'manage_url' => !empty($accountId) ? Url::fromRoute('myeventlane_vendor.stripe_manage')->toString() : NULL,
    ];
  }

  /**
   * Gets Boost status for an event.
   *
   * @param \Drupal\node\NodeInterface $event
   *   The event node.
   *
   * @return array
   *   Array with 'is_boosted', 'expires_date', 'boost_url', 'can_boost'.
   */
  private function getBoostStatus(\Drupal\node\NodeInterface $event): array {
    if (!$this->boostManager) {
      return [
        'is_boosted' => FALSE,
        'expires_date' => NULL,
        'boost_url' => NULL,
        'can_boost' => FALSE,
      ];
    }

    $isBoosted = $this->boostManager->isBoosted($event);
    $expiresDate = NULL;
    $canBoost = TRUE;

    if ($isBoosted && $event->hasField('field_promo_expires') && !$event->get('field_promo_expires')->isEmpty()) {
      $expiresValue = $event->get('field_promo_expires')->value;
      if ($expiresValue) {
        try {
          $expires = new \DateTimeImmutable($expiresValue, new \DateTimeZone('UTC'));
          $expiresDate = $expires->format('M j, Y');
        }
        catch (\Exception) {
          // Invalid date.
        }
      }
    }

    // Check if event is expired (boost ended).
    $isExpired = FALSE;
    if ($event->hasField('field_promoted') && (bool) $event->get('field_promoted')->value) {
      if ($expiresValue = $event->get('field_promo_expires')->value ?? NULL) {
        try {
          $expires = new \DateTimeImmutable($expiresValue, new \DateTimeZone('UTC'));
          $now = new \DateTimeImmutable('@' . $this->time->getRequestTime());
          $isExpired = $expires <= $now;
        }
        catch (\Exception) {
          // Invalid date.
        }
      }
    }

    return [
      'is_boosted' => $isBoosted,
      'is_expired' => $isExpired,
      'expires_date' => $expiresDate,
      'boost_url' => Url::fromRoute('myeventlane_boost.boost_page', ['node' => $event->id()])->toString(),
      'can_boost' => $canBoost,
    ];
  }

}

<?php

declare(strict_types=1);

use Drupal\Core\Form\FormStateInterface;
use Drupal\node\NodeInterface;
use Drupal\taxonomy\TermInterface;

/**
 * Implements hook_theme().
 */
function myeventlane_event_theme($existing, $type, $theme, $path) {
  return [
    'myeventlane_event_wizard_step' => [
      'variables' => [
        'title' => NULL,
        'step' => NULL,
        'form' => NULL,
        'steps' => [],
      ],
      'template' => 'event-wizard-step',
    ],
    'myeventlane_event_wizard_review' => [
      'variables' => [
        'title' => NULL,
        'event' => NULL,
        'steps' => [],
        'summary' => [],
        'publish_url' => NULL,
      ],
      'template' => 'event-wizard-review',
    ],
    'myeventlane_event_wizard_tickets' => [
      'variables' => [
        'title' => NULL,
        'event' => NULL,
        'event_type' => NULL,
        'steps' => [],
        'tickets_url' => NULL,
      ],
      'template' => 'event-wizard-tickets',
    ],
    'myeventlane_event_wizard_success' => [
      'variables' => [
        'title' => NULL,
        'event' => NULL,
        'event_url' => NULL,
        'tickets_url' => NULL,
        'create_url' => NULL,
      ],
      'template' => 'event-wizard-success',
    ],
  ];
}

/**
 * Implements hook_field_widget_form_alter().
 *
 * Fixes corrupted datetime field values in paragraph forms before widgets build.
 */
function myeventlane_event_field_widget_form_alter(array &$element, FormStateInterface $form_state, array $context): void {
  // Only process datetime fields in ticket_type_config paragraphs.
  if (!isset($context['fieldDefinition']) || !isset($context['items'])) {
    return;
  }

  $field_definition = $context['fieldDefinition'];
  $field_name = $field_definition->getName();
  
  // Only process the datetime fields we care about.
  if (!in_array($field_name, ['field_ticket_sales_start', 'field_ticket_sales_end'], TRUE)) {
    return;
  }

  // Check if this is a paragraph form.
  $items = $context['items'];
  if (!$items || !method_exists($items, 'getEntity')) {
    return;
  }

  $entity = $items->getEntity();
  if (!$entity || $entity->getEntityTypeId() !== 'paragraph' || $entity->bundle() !== 'ticket_type_config') {
    return;
  }

  // Fix corrupted values in the field items.
  if (!$items->isEmpty()) {
    $item = $items->first();
    if ($item) {
      $value = $item->getValue();
      // If 'value' is an array, clear it to fix the corruption.
      if (isset($value['value']) && is_array($value['value'])) {
        $items->setValue([]);
      }
    }
  }
}

/**
 * Implements hook_form_validate() for event forms.
 *
 * Excludes coordinate fields from validation - they're auto-populated by JavaScript.
 * Also handles false validation errors for fields that are populated but in wizard structure.
 * This hook runs AFTER field widget validation, so we can clear coordinate field errors.
 * 
 * IMPORTANT: This must run with high priority to clear errors before they're displayed.
 * We use a very specific hook name to ensure it runs after widget validation.
 */
function myeventlane_event_form_node_event_form_validate(array &$form, FormStateInterface $form_state): void {
  // Remove validation errors for coordinate fields - they're auto-populated by JavaScript.
  $coordinate_fields = [
    'field_location_latitude',
    'field_location_longitude',
    'field_event_lat',
    'field_event_lng',
  ];
  
  // Get all current errors.
  $errors = $form_state->getErrors();
  if (empty($errors)) {
    return;
  }
  
  // Log errors for debugging.
  \Drupal::logger('myeventlane_event')->debug('Validation errors found: @errors', [
    '@errors' => print_r(array_keys($errors), TRUE),
  ]);
  
  // Check if any errors are for coordinate fields and collect non-coordinate errors.
  $has_coordinate_errors = FALSE;
  $other_errors = [];
  
  // Also check for false validation errors on fields that might be in wizard structure.
  // These fields might have values but validation is failing because form values aren't extracted yet.
  $entity = $form_state->getFormObject()->getEntity();
  
  foreach ($errors as $key => $error) {
    $is_coordinate_error = FALSE;
    foreach ($coordinate_fields as $field_name) {
      // Check both direct field name and nested paths (e.g., field_location_latitude[0][value]).
      // Also check for variations like field_location_latitude[0][value], etc.
      // Use case-insensitive matching to catch all variations.
      $key_lower = strtolower($key);
      $field_lower = strtolower($field_name);
      // Check for various error key formats:
      // - field_location_latitude
      // - field_location_latitude[0][value]
      // - field_location_latitude][0][value (if brackets are encoded)
      if (str_contains($key_lower, $field_lower) || 
          str_contains($key, $field_name) ||
          preg_match('/' . preg_quote($field_name, '/') . '[\[\]]/', $key)) {
        $is_coordinate_error = TRUE;
        $has_coordinate_errors = TRUE;
        \Drupal::logger('myeventlane_event')->debug('Found coordinate error for field @field: @key', [
          '@field' => $field_name,
          '@key' => $key,
        ]);
        break;
      }
    }
    
    // Check for false validation errors on fields that might have values in the form.
    // This happens when fields are in wizard structure but form values aren't extracted yet.
    if (!$is_coordinate_error) {
      // Check if this is a required field error for a field that might be populated.
      // We'll check the form values directly to see if the field has a value.
      $field_has_value = FALSE;
      
      // Check common field patterns in error keys.
      if (str_contains($key, 'field_event_start') || str_contains($key, 'event_start')) {
        // Check if datetime field has values in form.
        $form_values = $form_state->getValues();
        if (isset($form_values['field_event_start'][0]['value']['date']) && 
            !empty($form_values['field_event_start'][0]['value']['date'])) {
          $field_has_value = TRUE;
        }
        // Also check wizard structure.
        if (!$field_has_value && isset($form['mel_wizard']['layout']['content']['step_basics']['section']['field_event_start'])) {
          $field_has_value = TRUE; // Field exists in wizard, assume it might have value
        }
      }
      elseif (str_contains($key, 'field_location') || str_contains($key, 'address_line1') || str_contains($key, 'street_address')) {
        // Check if address field has values in form.
        $form_values = $form_state->getValues();
        if (isset($form_values['field_location'][0]['address']['address_line1']) && 
            !empty($form_values['field_location'][0]['address']['address_line1'])) {
          $field_has_value = TRUE;
        }
        // Also check wizard structure.
        if (!$field_has_value && isset($form['mel_wizard']['layout']['content']['step_basics']['section']['field_location'])) {
          $field_has_value = TRUE; // Field exists in wizard, assume it might have value
        }
      }
      
      // If field has a value but validation is still failing, it's likely a false error.
      // We'll keep the error for now but log it for debugging.
      if ($field_has_value) {
        \Drupal::logger('myeventlane_event')->warning('Field @key has value but validation error exists. This may be a false error due to wizard structure.', [
          '@key' => $key,
        ]);
      }
      
      $other_errors[$key] = $error;
    }
  }
  
  // If we found coordinate field errors, clear all errors and re-add only non-coordinate errors.
  if ($has_coordinate_errors) {
    \Drupal::logger('myeventlane_event')->debug('Clearing @count coordinate errors, keeping @other_count other errors', [
      '@count' => count($errors) - count($other_errors),
      '@other_count' => count($other_errors),
    ]);
    $form_state->clearErrors();
    foreach ($other_errors as $key => $error) {
      $form_state->setErrorByName($key, $error);
    }
  }
}

/**
 * Implements hook_form_alter().
 */
function myeventlane_event_form_alter(array &$form, FormStateInterface $form_state, string $form_id): void {
  // Ticket type paragraph conditional logic.
  \Drupal\myeventlane_event\Form\TicketTypeFormAlter::alterForm($form, $form_state);
}

/**
 * Implements hook_form_node_event_form_alter().
 *
 * This specific hook runs AFTER hook_form_alter, ensuring we can remove
 * conflicting elements added by other modules (like vendor module's tabs).
 */
function myeventlane_event_form_node_event_form_alter(array &$form, FormStateInterface $form_state, string $form_id): void {
  /** @var \Drupal\myeventlane_event\Form\EventFormAlter $alter */
  $alter = \Drupal::service('myeventlane_event.event_form_alter');
  $alter->alterForm($form, $form_state, $form_id);
  
  // CRITICAL: Final safety check - ensure buttons ALWAYS exist and are visible.
  // This runs AFTER all other form alters to ensure nothing can remove our buttons.
  
  // Ensure actions container exists and is visible.
  if (!isset($form['actions'])) {
    $form['actions'] = [
      '#type' => 'actions',
      '#weight' => 1000,
    ];
  }
  $form['actions']['#access'] = TRUE;
  
  // Ensure buttons exist - call this again to be absolutely sure.
  $alter->ensureActionButtons($form, $form_state);
  
  // CRITICAL: Force buttons to exist and be visible - create if missing.
  $form_object = $form_state->getFormObject();
  
  if (!isset($form['actions']['submit']) || (isset($form['actions']['submit']['#access']) && $form['actions']['submit']['#access'] === FALSE)) {
    $submit_handlers = [];
    $submit_handlers[] = ['\Drupal\myeventlane_event\Form\EventFormAlter', 'submitPublish'];
    if ($form_object instanceof \Drupal\Core\Entity\EntityFormInterface) {
      $submit_handlers[] = [$form_object, 'save'];
    }
    $submit_handlers[] = ['\Drupal\myeventlane_event\Form\EventFormAlter', 'submitPublishPostSave'];
    $form['actions']['submit'] = [
      '#type' => 'submit',
      '#value' => t('Publish event'),
      '#submit' => $submit_handlers,
      '#access' => TRUE,
      '#weight' => 10,
      '#attributes' => ['class' => ['button', 'button--primary']],
    ];
  } else {
    $form['actions']['submit']['#access'] = TRUE;
  }
  
  if (!isset($form['actions']['save_draft']) || (isset($form['actions']['save_draft']['#access']) && $form['actions']['save_draft']['#access'] === FALSE)) {
    $submit_handlers = [];
    $submit_handlers[] = ['\Drupal\myeventlane_event\Form\EventFormAlter', 'submitSaveDraft'];
    if ($form_object instanceof \Drupal\Core\Entity\EntityFormInterface) {
      $submit_handlers[] = [$form_object, 'save'];
    }
    $form['actions']['save_draft'] = [
      '#type' => 'submit',
      '#value' => t('Save draft'),
      '#submit' => $submit_handlers,
      '#access' => TRUE,
      '#weight' => 5,
      '#attributes' => ['class' => ['button']],
    ];
  } else {
    $form['actions']['save_draft']['#access'] = TRUE;
  }
  
  // Ensure buttons have proper attributes.
  foreach (['submit', 'save_draft'] as $button_key) {
    if (isset($form['actions'][$button_key])) {
      if (!isset($form['actions'][$button_key]['#attributes'])) {
        $form['actions'][$button_key]['#attributes'] = [];
      }
      if (!isset($form['actions'][$button_key]['#attributes']['class'])) {
        $form['actions'][$button_key]['#attributes']['class'] = [];
      }
      if (!in_array('button', $form['actions'][$button_key]['#attributes']['class'])) {
        $form['actions'][$button_key]['#attributes']['class'][] = 'button';
      }
    }
  }
}

/**
 * Implements hook_preprocess_field().
 */
function myeventlane_event_preprocess_field(array &$variables): void {
  // Hide venue name field for vendors (non-admins).
  if (isset($variables['element']['#field_name']) && $variables['element']['#field_name'] === 'field_venue_name') {
    $current_user = \Drupal::currentUser();
    $is_admin = $current_user->hasPermission('administer nodes') || $current_user->hasPermission('bypass node access');
    
    if (!$is_admin) {
      // Add class to wrapper attributes to hide the field.
      if (!isset($variables['attributes']['class'])) {
        $variables['attributes']['class'] = [];
      }
      if (!in_array('hide-venue-name', $variables['attributes']['class'])) {
        $variables['attributes']['class'][] = 'hide-venue-name';
      }
      // Also add a data attribute for JavaScript targeting if needed.
      if (!isset($variables['attributes']['data-venue-name-hidden'])) {
        $variables['attributes']['data-venue-name-hidden'] = 'true';
      }
    }
  }
}

/**
 * Implements hook_entity_load().
 *
 * Fixes corrupted datetime field values in ticket type paragraphs.
 * This prevents the error: "DateTime::createFromFormat(): Argument #2 ($datetime)
 * must be of type string, array given".
 */
function myeventlane_event_entity_load(array $entities, string $entity_type): void {
  if ($entity_type !== 'paragraph') {
    return;
  }

  foreach ($entities as $entity) {
    if ($entity->bundle() !== 'ticket_type_config') {
      continue;
    }

    // Fix datetime fields that have array values instead of strings.
    $datetime_fields = ['field_ticket_sales_start', 'field_ticket_sales_end'];
    foreach ($datetime_fields as $field_name) {
      if ($entity->hasField($field_name)) {
        $field = $entity->get($field_name);
        if (!$field->isEmpty()) {
          $item = $field->first();
          if ($item) {
            $value = $item->getValue();
            // If 'value' is an array, clear the field to fix the corruption.
            if (isset($value['value']) && is_array($value['value'])) {
              $field->setValue([]);
            }
          }
        }
      }
    }
  }
}

/**
 * Implements hook_entity_presave().
 *
 * Prevents saving corrupted datetime field values in ticket type paragraphs.
 */
function myeventlane_event_entity_presave(\Drupal\Core\Entity\EntityInterface $entity): void {
  if ($entity->getEntityTypeId() !== 'paragraph' || $entity->bundle() !== 'ticket_type_config') {
    return;
  }

  // Fix datetime fields that have array values instead of strings before saving.
  $datetime_fields = ['field_ticket_sales_start', 'field_ticket_sales_end'];
  foreach ($datetime_fields as $field_name) {
    if ($entity->hasField($field_name)) {
      $field = $entity->get($field_name);
      if (!$field->isEmpty()) {
        $item = $field->first();
        if ($item) {
          $value = $item->getValue();
          // If 'value' is an array, clear the field to fix the corruption.
          if (isset($value['value']) && is_array($value['value'])) {
            $field->setValue([]);
          }
        }
      }
    }
  }
}

/**
 * Implements hook_preprocess_node().
 */
function myeventlane_event_preprocess_node(array &$variables): void {
  if (empty($variables['node']) || !$variables['node'] instanceof NodeInterface) {
    return;
  }

  $node = $variables['node'];
  if ($node->bundle() !== 'event') {
    return;
  }

  // Defaults.
  $lat = NULL;
  $lng = NULL;

  // Pull coords if present.
  if ($node->hasField('field_event_lat') && !$node->get('field_event_lat')->isEmpty()) {
    $lat = (float) $node->get('field_event_lat')->value;
  }
  if ($node->hasField('field_event_lng') && !$node->get('field_event_lng')->isEmpty()) {
    $lng = (float) $node->get('field_event_lng')->value;
  }

  // Expose coords to Twig if needed.
  $variables['mel_event_lat'] = $lat;
  $variables['mel_event_lng'] = $lng;

  // Categories metadata for theming (name + color).
  $categories = [];
  if ($node->hasField('field_event_categories') && !$node->get('field_event_categories')->isEmpty()) {
    foreach ($node->get('field_event_categories')->referencedEntities() as $term) {
      if ($term instanceof TermInterface) {
        $color = NULL;
        if ($term->hasField('field_term_color') && !$term->get('field_term_color')->isEmpty()) {
          $color = $term->get('field_term_color')->value;
        }
        $categories[] = [
          'name' => $term->label(),
          'color' => $color,
        ];
      }
    }
  }
  $variables['mel_categories'] = $categories;

  // Attach the map library if coords exist.
  if ($lat !== NULL && $lng !== NULL) {
    $variables['#attached']['library'][] = 'myeventlane_location/event_map';
  }
}

<?php

declare(strict_types=1);

use Drupal\Core\Form\FormStateInterface;
use Drupal\commerce_price\Price;
use Drupal\commerce_product\Entity\ProductInterface;
use Drupal\commerce_product\Entity\ProductVariationInterface;
use Drupal\node\NodeInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\StringTranslation\TranslatableMarkup;

/**
 * Helper: find the quantity number element in ATC form (various widget shapes).
 */
function &_myeventlane_commerce_get_qty_ref(array &$form) {
  if (isset($form['quantity'][0]['value']) && is_array($form['quantity'][0]['value'])) {
    return $form['quantity'][0]['value'];
  }
  if (isset($form['quantity']['widget'][0]['value']) && is_array($form['quantity']['widget'][0]['value'])) {
    return $form['quantity']['widget'][0]['value'];
  }
  foreach ($form as &$child) {
    if (is_array($child) && (($child['#type'] ?? '') === 'number')) {
      $name = $child['#name'] ?? '';
      $parents = implode('.', $child['#parents'] ?? []);
      if (stripos($name, 'quantity') !== FALSE || stripos($parents, 'quantity') !== FALSE) {
        return $child;
      }
    }
  }
  $null = NULL;
  return $null;
}

/* ==========================================================================
 * ðŸ§© AUTO-LINK EVENT FIELD BETWEEN PRODUCT AND VARIATIONS
 * ========================================================================== */

/**
 * Implements hook_entity_presave().
 *
 * Auto-link the product's field_event to all its variations.
 */
function myeventlane_commerce_entity_presave(EntityInterface $entity): void {
  // Only act on Commerce Products.
  if ($entity instanceof ProductInterface && $entity->hasField('field_event')) {

    // Ensure product has an event reference.
    if (!$entity->get('field_event')->isEmpty()) {
      $event_target = $entity->get('field_event')->target_id;

      // Loop through each variation.
      foreach ($entity->getVariations() as $variation) {
        if ($variation->hasField('field_event')) {
          $current = $variation->get('field_event')->target_id ?? NULL;

          // Only update if empty or mismatched.
          if (empty($current) || $current != $event_target) {
            $variation->set('field_event', ['target_id' => $event_target]);
            $variation->save();

            \Drupal::logger('myeventlane_commerce')->notice('ðŸ”— Auto-linked variation @var â†’ event @event', [
              '@var' => $variation->label(),
              '@event' => $event_target,
            ]);
          }
        }
      }
    }
  }
}

/**
 * Implements hook_entity_insert() and hook_entity_update() for Event nodes.
 *
 * Ensures variations are updated if the Event node changes.
 */
function myeventlane_commerce_entity_insert(EntityInterface $entity): void {
  _myeventlane_commerce_sync_event_variations($entity);
}
function myeventlane_commerce_entity_update(EntityInterface $entity): void {
  _myeventlane_commerce_sync_event_variations($entity);
}

/**
 * Syncs Event â†’ Product â†’ Variations (reverse link).
 */
function _myeventlane_commerce_sync_event_variations(EntityInterface $entity): void {
  if ($entity instanceof NodeInterface && $entity->bundle() === 'event') {
    $event_id = $entity->id();

    // Load all products referencing this event.
    $products = \Drupal::entityTypeManager()
      ->getStorage('commerce_product')
      ->loadByProperties(['field_event' => $event_id]);

    if (empty($products)) {
      \Drupal::logger('myeventlane_commerce')->notice('No products found for Event @id', ['@id' => $event_id]);
      return;
    }

    foreach ($products as $product) {
      foreach ($product->getVariations() as $variation) {
        if (
          $variation->hasField('field_event') &&
          $variation->get('field_event')->target_id != $event_id
        ) {
          $variation->set('field_event', ['target_id' => $event_id]);
          $variation->save();

          \Drupal::logger('myeventlane_commerce')->notice('âœ… Synced variation @var â†’ Event @event', [
            '@var' => $variation->label(),
            '@event' => $entity->label(),
          ]);
        }
      }
    }
  }
}

/* ==========================================================================
 * ðŸ›’ ADD-TO-CART FORM CUSTOMIZATION
 * ========================================================================== */

/**
 * Alter Commerce add-to-cart forms (labels, validation, drupalSettings).
 */
function myeventlane_commerce_form_commerce_order_item_add_to_cart_form_alter(array &$form, FormStateInterface $form_state, $form_id): void {
  // Attach JS/CSS.
  $form['#attached']['library'][] = 'myeventlane_theme/ticket_matrix';

  // Stable unique ID.
  if (empty($form['#attributes']['id'])) {
    $form['#attributes']['id'] = 'mel-atc-' . \Drupal::service('uuid')->generate();
  }
  $form['#attributes']['class'][] = 'mel-atc-form';

  // Friendly labels + hide unit price override.
  if (isset($form['purchased_entity'])) { $form['purchased_entity']['#title'] = t('Ticket Type'); }
  if (isset($form['quantity']))        { $form['quantity']['#title']        = t('Quantity'); }
  if (isset($form['unit_price']))      { $form['unit_price']['#access']     = FALSE; }

  // Force quantity constraints + default to 0.
  if ($qty =& _myeventlane_commerce_get_qty_ref($form)) {
    $qty['#min'] = 0;
    $qty['#step'] = 1;
    $qty['#default_value'] = 0;
  }

  // Validation: block qty = 0.
  $form['#validate'] = array_merge(
    ['myeventlane_commerce_atc_validate_qty'],
    $form['#validate'] ?? []
  );

  // Expose variation prices for the JS decorator.
  $prices = [];
  $single_option = FALSE;
  $var_el = $form['purchased_entity']['widget'][0]['variation'] ?? NULL;

  if (is_array($var_el) && !empty($var_el['#options__entities'])) {
    $single_option = (count($var_el['#options__entities']) === 1);
    foreach ($var_el['#options__entities'] as $id => $variation) {
      if ($variation instanceof ProductVariationInterface) {
        $p = $variation->getPrice();
        if ($p instanceof Price) {
          $prices[(string) $id] = \Drupal::service('commerce_price.currency_formatter')
            ->format($p->getNumber(), $p->getCurrencyCode());
        }
      }
    }
  }

  $form_id_html = $form['#attributes']['id'];
  $form['#attached']['drupalSettings']['melTicketMatrix'][$form_id_html] = [
    'prices'       => $prices,
    'singleOption' => $single_option,
  ];
}

/**
 * Validation: prevent adding to cart with 0 quantity.
 */
function myeventlane_commerce_atc_validate_qty(array &$form, FormStateInterface $form_state): void {
  $qty = (int) ($form_state->getValue(['quantity', 0, 'value'])
    ?? $form_state->getValue('quantity')
    ?? 0);
  if ($qty === 0) {
    $form_state->setErrorByName('quantity][0][value', t('Please choose at least one ticket.'));
  }
}

/**
 * Implements hook_theme().
 */
function myeventlane_commerce_theme(): array {
  return [
    'myeventlane_event_book' => [
      'variables' => [
        'title' => NULL,
        'event_date_text' => '',
        'venue_text' => '',
        'hero_url' => '',
        'matrix_form' => [],
      ],
      'template' => 'myeventlane-event-book',
    ],
  ];
}

/**
 * Ensure theme templates under /templates/commerce are discovered.
 */
function myeventlane_commerce_theme_registry_alter(array &$registry): void {
  if (isset($registry['commerce_product'])) {
    $theme = \Drupal::theme()->getActiveTheme()->getName();
    $theme_path = \Drupal::service('extension.list.theme')->getPath($theme);
    $registry['commerce_product']['path'] = $theme_path . '/templates/commerce';
  }
}

/**
 * Implements hook_ENTITY_TYPE_presave() for commerce_order_item.
 *
 * Auto-populates field_target_event from the purchased variation.
 */
function myeventlane_commerce_commerce_order_item_presave(EntityInterface $entity): void {
  // Only process if field_target_event exists and is empty.
  if (!$entity->hasField('field_target_event') || !$entity->get('field_target_event')->isEmpty()) {
    return;
  }

  // Get purchased entity (variation).
  $purchasedEntity = $entity->getPurchasedEntity();
  if (!$purchasedEntity || !$purchasedEntity->hasField('field_event')) {
    return;
  }

  // Get event ID from variation.
  $eventId = $purchasedEntity->get('field_event')->target_id;
  if ($eventId) {
    $entity->set('field_target_event', ['target_id' => $eventId]);
    \Drupal::logger('myeventlane_commerce')->notice('Auto-linked order item @item to event @event', [
      '@item' => $entity->id(),
      '@event' => $eventId,
    ]);
  }
}

/**
 * Implements hook_commerce_checkout_pane_info_alter().
 *
 * Restores the billing_information pane that commerce_payment removes.
 * This allows us to have a separate "Billing Information" section in checkout
 * even when payment gateways are enabled.
 * 
 * This hook runs after commerce_payment's hook (due to module dependencies),
 * so we can restore the pane after it's been removed.
 */
function myeventlane_commerce_commerce_checkout_pane_info_alter(array &$definitions): void {
  // Restore billing_information pane if it was removed by commerce_payment.
  // We check if it exists first to avoid duplicates.
  if (!isset($definitions['billing_information'])) {
    // Manually restore the billing_information pane definition.
    // Based on the CommerceCheckoutPane attribute in BillingInformation class.
    // This matches what the plugin discovery system would provide.
    $definitions['billing_information'] = [
      'id' => 'billing_information',
      'label' => new TranslatableMarkup('Billing information'),
      'default_step' => 'order_information',
      'wrapper_element' => 'fieldset',
      'class' => 'Drupal\commerce_checkout\Plugin\Commerce\CheckoutPane\BillingInformation',
      'provider' => 'commerce_checkout',
    ];
  }
}

/**
 * Implements hook_form_alter().
 *
 * Remove duplicate billing information from payment_information pane.
 */
function myeventlane_commerce_form_alter(array &$form, FormStateInterface $form_state, string $form_id): void {
  // Apply only on Commerce checkout forms.
  if (!isset($form['#id']) || !str_contains($form['#id'], 'commerce-checkout')) {
    return;
  }
  
  // If billing_information exists as a top-level pane, remove it from payment_information.
  // Only do this if payment_information has been built (has #payment_options or other pane structure).
  // We need to be careful not to interfere with the pane's internal structure.
  if (isset($form['billing_information']) && is_array($form['billing_information'])) {
    // Only remove billing_information from payment_information if:
    // 1. payment_information exists and is an array
    // 2. payment_information has been built (has #payment_options or payment_method element)
    // 3. billing_information exists within payment_information
    if (isset($form['payment_information']) 
        && is_array($form['payment_information'])
        && (isset($form['payment_information']['#payment_options']) || isset($form['payment_information']['payment_method']))
        && isset($form['payment_information']['billing_information'])) {
      // Safely remove only the billing_information element, not affecting other pane structure.
      unset($form['payment_information']['billing_information']);
    }
  }

  // Add safety checks for payment_information pane to prevent errors during submission.
  // The core Commerce code doesn't check if #payment_options exists before accessing it.
  if (isset($form['payment_information']) && is_array($form['payment_information'])) {
    // Add an after_build callback to ensure structure is preserved.
    if (!isset($form['payment_information']['#after_build'])) {
      $form['payment_information']['#after_build'] = [];
    }
    $form['payment_information']['#after_build'][] = 'myeventlane_commerce_payment_information_after_build';
    
    // Add validation to prevent submission if payment_options is empty.
    if (!isset($form['payment_information']['#validate'])) {
      $form['payment_information']['#validate'] = [];
    }
    $form['payment_information']['#validate'][] = 'myeventlane_commerce_validate_payment_information';
    
    // Add a submit handler that runs before the pane's submit to add safety checks.
    // We'll prepend it so it runs first.
    if (!isset($form['#submit'])) {
      $form['#submit'] = [];
    }
    array_unshift($form['#submit'], 'myeventlane_commerce_checkout_form_submit_safety_check');
  }
}

/**
 * After build callback for payment_information pane.
 *
 * Ensures the pane structure is correct and sets #payment_options to empty array if missing.
 * This prevents the "Call to a member function getPaymentGatewayId() on null" error.
 */
function myeventlane_commerce_payment_information_after_build(array $element, FormStateInterface $form_state): array {
  // If #payment_options is missing, set it to an empty array.
  // This prevents errors in submitPaneForm when it tries to access #payment_options.
  // The core Commerce code should check for this, but it doesn't, so we work around it.
  if (!isset($element['#payment_options'])) {
    $element['#payment_options'] = [];
    \Drupal::logger('myeventlane_commerce')->warning('Payment information pane is missing #payment_options. Setting to empty array to prevent submission errors. This may indicate the pane was not properly built (e.g., no payment gateways available).');
  }
  
  return $element;
}

/**
 * Validation callback for payment_information pane.
 *
 * Prevents submission if #payment_options is empty or if selected payment_method is invalid.
 */
function myeventlane_commerce_validate_payment_information(array &$element, FormStateInterface $form_state): void {
  // Get the values for this pane.
  $values = $form_state->getValue($element['#parents'] ?? []);
  
  // If #payment_options is empty, we can't proceed.
  if (empty($element['#payment_options'])) {
    \Drupal::logger('myeventlane_commerce')->error('Payment information pane has empty #payment_options. Cannot proceed with payment.');
    $form_state->setError($element, t('No payment methods are available. Please contact support.'));
    return;
  }
  
  // If payment_method is set, validate it exists in #payment_options.
  if (isset($values['payment_method'])) {
    if (!isset($element['#payment_options'][$values['payment_method']])) {
      \Drupal::logger('myeventlane_commerce')->error('Selected payment method @method does not exist in payment options.', ['@method' => $values['payment_method']]);
      if (isset($element['payment_method'])) {
        $form_state->setError($element['payment_method'], t('Invalid payment method selected. Please choose a payment method.'));
      } else {
        $form_state->setError($element, t('Invalid payment method selected.'));
      }
    }
  }
}

/**
 * Submit handler for checkout form - safety check before payment pane submission.
 *
 * This runs before the pane's submitPaneForm to ensure #payment_options exists.
 * Note: This may not prevent the error if submitPaneForm is called directly by the checkout flow,
 * but it helps ensure the structure is correct.
 */
function myeventlane_commerce_checkout_form_submit_safety_check(array &$form, FormStateInterface $form_state): void {
  // Check if payment_information pane is being submitted and has required structure.
  if (isset($form['payment_information']) && is_array($form['payment_information'])) {
    // Ensure #payment_options exists (should have been set by after_build, but double-check).
    if (!isset($form['payment_information']['#payment_options'])) {
      $form['payment_information']['#payment_options'] = [];
      \Drupal::logger('myeventlane_commerce')->warning('Payment information pane #payment_options missing in submit handler. Setting to empty array.');
    }
    
    $values = $form_state->getValue($form['payment_information']['#parents'] ?? []);
    
    // If payment_method is set but doesn't exist in #payment_options, that's a problem.
    if (isset($values['payment_method']) && !empty($form['payment_information']['#payment_options'])) {
      if (!isset($form['payment_information']['#payment_options'][$values['payment_method']])) {
        \Drupal::logger('myeventlane_commerce')->error('Selected payment method @method does not exist in payment options.', ['@method' => $values['payment_method']]);
        // Clear the invalid payment_method value.
        $form_state->setValue(array_merge($form['payment_information']['#parents'] ?? [], ['payment_method']), NULL);
      }
    }
  }
}